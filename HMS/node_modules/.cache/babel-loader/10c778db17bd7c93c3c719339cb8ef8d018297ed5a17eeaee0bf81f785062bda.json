{"ast":null,"code":"'use client';\n\nimport { useState, useRef, useMemo, useCallback } from 'react';\nimport { getInputOnChange } from './get-input-on-change/get-input-on-change.mjs';\nimport 'klona/full';\nimport { shouldValidateOnChange } from './validate/should-validate-on-change.mjs';\nfunction useField({\n  mode = \"controlled\",\n  clearErrorOnChange = true,\n  initialValue,\n  initialError = null,\n  initialTouched = false,\n  onValueChange,\n  validateOnChange = false,\n  validateOnBlur = false,\n  validate,\n  resolveValidationError,\n  type = \"input\"\n}) {\n  const [valueState, setValueState] = useState(initialValue);\n  const valueRef = useRef(valueState);\n  const [key, setKey] = useState(0);\n  const [error, setError] = useState(initialError || null);\n  const touchedRef = useRef(initialTouched || false);\n  const [, setTouchedState] = useState(touchedRef.current);\n  const [isValidating, setIsValidating] = useState(false);\n  const errorResolver = useMemo(() => resolveValidationError || (err => err), [resolveValidationError]);\n  const setTouched = useCallback((val, {\n    updateState = mode === \"controlled\"\n  } = {}) => {\n    touchedRef.current = val;\n    updateState && setTouchedState(val);\n  }, []);\n  const setValue = useCallback((value, {\n    updateKey = mode === \"uncontrolled\",\n    updateState = mode === \"controlled\"\n  } = {}) => {\n    if (valueRef.current === value) {\n      return;\n    }\n    valueRef.current = value;\n    onValueChange?.(value);\n    if (clearErrorOnChange && error !== null) {\n      setError(null);\n    }\n    if (updateState) {\n      setValueState(value);\n    }\n    if (updateKey) {\n      setKey(currentKey => currentKey + 1);\n    }\n    if (validateOnChange) {\n      _validate();\n    }\n  }, [error, clearErrorOnChange, onValueChange]);\n  const reset = useCallback(() => {\n    setValue(initialValue);\n    setError(null);\n    setTouched(false);\n  }, [initialValue]);\n  const getValue = useCallback(() => valueRef.current, []);\n  const isTouched = useCallback(() => touchedRef.current, []);\n  const isDirty = useCallback(() => valueRef.current !== initialValue, [initialValue]);\n  const _validate = useCallback(async () => {\n    const validationResult = validate?.(valueRef.current);\n    if (validationResult instanceof Promise) {\n      setIsValidating(true);\n      try {\n        const result = await validationResult;\n        setIsValidating(false);\n        setError(result);\n      } catch (err) {\n        setIsValidating(false);\n        const resolvedError = errorResolver(err);\n        setError(resolvedError);\n        return resolvedError;\n      }\n    } else {\n      setError(validationResult);\n      return validationResult;\n    }\n  }, []);\n  const getInputProps = ({\n    withError = true,\n    withFocus = true\n  } = {}) => {\n    const onChange = getInputOnChange(val => setValue(val, {\n      updateKey: false\n    }));\n    const payload = {\n      onChange\n    };\n    if (withError) {\n      payload.error = error;\n    }\n    if (type === \"checkbox\") {\n      payload[mode === \"controlled\" ? \"checked\" : \"defaultChecked\"] = valueRef.current;\n    } else {\n      payload[mode === \"controlled\" ? \"value\" : \"defaultValue\"] = valueRef.current;\n    }\n    if (withFocus) {\n      payload.onFocus = () => {\n        setTouched(true);\n      };\n      payload.onBlur = () => {\n        if (shouldValidateOnChange(\"\", !!validateOnBlur)) {\n          _validate();\n        }\n      };\n    }\n    return payload;\n  };\n  const resetTouched = useCallback(() => setTouched(false), []);\n  return {\n    key,\n    getValue,\n    setValue,\n    reset,\n    getInputProps,\n    isValidating,\n    validate: _validate,\n    error,\n    setError,\n    isTouched,\n    isDirty,\n    resetTouched\n  };\n}\nexport { useField };","map":{"version":3,"names":["useField","mode","clearErrorOnChange","initialValue","initialError","initialTouched","onValueChange","validateOnChange","validateOnBlur","validate","resolveValidationError","type","valueState","setValueState","useState","valueRef","useRef","key","setKey","error","setError","touchedRef","setTouchedState","current","isValidating","setIsValidating","errorResolver","useMemo","err","setTouched","useCallback","val","updateState","setValue","value","updateKey","currentKey","_validate","reset","getValue","isTouched","isDirty","validationResult","Promise","result","resolvedError","getInputProps","withError","withFocus","onChange","getInputOnChange","payload","onFocus","onBlur","shouldValidateOnChange","resetTouched"],"sources":["E:\\HOCCODE\\HMS\\FRONTEND\\HMS\\node_modules\\@mantine\\form\\src\\use-field.ts"],"sourcesContent":["import { useCallback, useMemo, useRef, useState } from 'react';\nimport { getInputOnChange } from './get-input-on-change';\nimport { FormMode, GetInputPropsType } from './types';\nimport { shouldValidateOnChange } from './validate';\n\ntype UseFieldErrorResolver = (error: unknown) => React.ReactNode;\n\nexport interface UseFieldInput<\n  T,\n  FieldType extends GetInputPropsType = 'input',\n  Mode extends FormMode = 'controlled',\n> {\n  /** Field mode, controlled by default */\n  mode?: Mode;\n\n  /** Initial field value */\n  initialValue: T;\n\n  /** Initial touched value */\n  initialTouched?: boolean;\n\n  /** Initial field error message */\n  initialError?: React.ReactNode;\n\n  /** Called with updated value when the field value changes */\n  onValueChange?: (value: T) => void;\n\n  /** Determines whether the field should be validated when value changes, false by default */\n  validateOnChange?: boolean;\n\n  /** Determines whether the field should be validated when it loses focus, false by default */\n  validateOnBlur?: boolean;\n\n  /** Determines whether the field should clear error message when value changes, true by default */\n  clearErrorOnChange?: boolean;\n\n  /** A function to validate field value, can be sync or async */\n  validate?: (value: T) => React.ReactNode | Promise<React.ReactNode>;\n\n  /** Field type, input by default */\n  type?: FieldType;\n\n  /** A function to resolve validation error from the result returned from validate function, should return react node */\n  resolveValidationError?: UseFieldErrorResolver;\n}\n\ninterface SetValueOptions {\n  updateState?: boolean;\n  updateKey?: boolean;\n}\n\ninterface GetInputPropsOptions {\n  withError?: boolean;\n  withFocus?: boolean;\n}\n\ninterface GetInputPropsSharedReturn {\n  error?: React.ReactNode;\n  onFocus?: () => void;\n  onBlur: () => void;\n  onChange: (value: any) => void;\n}\n\ntype GetInputPropsTypeValue<\n  T,\n  FieldType extends GetInputPropsType,\n  Mode extends FormMode,\n> = FieldType extends 'checkbox'\n  ? Mode extends 'controlled'\n    ? { checked: boolean }\n    : { defaultChecked: boolean }\n  : Mode extends 'controlled'\n    ? { value: T }\n    : { defaultValue: T };\n\ntype GetInputPropsReturnType<\n  T,\n  FieldType extends GetInputPropsType,\n  Mode extends FormMode,\n> = GetInputPropsSharedReturn & GetInputPropsTypeValue<T, FieldType, Mode>;\n\nexport interface UseFieldReturnType<\n  T,\n  FieldType extends GetInputPropsType = 'input',\n  Mode extends FormMode = 'controlled',\n> {\n  /** Returns props to pass to the input element */\n  getInputProps: (options?: GetInputPropsOptions) => GetInputPropsReturnType<T, FieldType, Mode>;\n\n  /** Returns current input value */\n  getValue: () => T;\n\n  /** Sets input value to the given value */\n  setValue: (value: T) => void;\n\n  /** Resets field value to initial state, sets touched state to false, sets error to null */\n  reset: () => void;\n\n  /** Validates current input value when called */\n  validate: () => Promise<React.ReactNode | void>;\n\n  /** Set to true when async validate function is called, stays true until the returned promise resolves */\n  isValidating: boolean;\n\n  /** Current error message */\n  error: React.ReactNode;\n\n  /** Sets error message to the given react node */\n  setError: (error: React.ReactNode) => void;\n\n  /** Returns true if the input has been focused at least once */\n  isTouched: () => boolean;\n\n  /** Returns true if input value is different from the initial value */\n  isDirty: () => boolean;\n\n  /** Resets touched state to false */\n  resetTouched: () => void;\n\n  /** Key that should be added to the input when mode is uncontrolled */\n  key: number;\n}\n\nexport function useField<\n  T,\n  Mode extends FormMode = 'controlled',\n  FieldType extends GetInputPropsType = 'input',\n>({\n  mode = 'controlled' as Mode,\n  clearErrorOnChange = true,\n  initialValue,\n  initialError = null,\n  initialTouched = false,\n  onValueChange,\n  validateOnChange = false,\n  validateOnBlur = false,\n  validate,\n  resolveValidationError,\n  type = 'input' as FieldType,\n}: UseFieldInput<T, FieldType, Mode>): UseFieldReturnType<T, FieldType, Mode> {\n  const [valueState, setValueState] = useState(initialValue);\n  const valueRef = useRef(valueState);\n  const [key, setKey] = useState(0);\n  const [error, setError] = useState<React.ReactNode>(initialError || null);\n  const touchedRef = useRef(initialTouched || false);\n  const [, setTouchedState] = useState(touchedRef.current);\n  const [isValidating, setIsValidating] = useState(false);\n  const errorResolver: UseFieldErrorResolver = useMemo(\n    () => resolveValidationError || ((err) => err as React.ReactNode),\n    [resolveValidationError]\n  );\n\n  const setTouched = useCallback((val: boolean, { updateState = mode === 'controlled' } = {}) => {\n    touchedRef.current = val;\n    updateState && setTouchedState(val);\n  }, []);\n\n  const setValue = useCallback(\n    (\n      value: T,\n      {\n        updateKey = mode === 'uncontrolled',\n        updateState = mode === 'controlled',\n      }: SetValueOptions = {}\n    ) => {\n      if (valueRef.current === value) {\n        return;\n      }\n\n      valueRef.current = value;\n\n      onValueChange?.(value);\n\n      if (clearErrorOnChange && error !== null) {\n        setError(null);\n      }\n\n      if (updateState) {\n        setValueState(value);\n      }\n\n      if (updateKey) {\n        setKey((currentKey) => currentKey + 1);\n      }\n\n      if (validateOnChange) {\n        _validate();\n      }\n    },\n    [error, clearErrorOnChange, onValueChange]\n  );\n\n  const reset = useCallback(() => {\n    setValue(initialValue);\n    setError(null);\n    setTouched(false);\n  }, [initialValue]);\n\n  const getValue = useCallback(() => valueRef.current, []);\n\n  const isTouched = useCallback(() => touchedRef.current, []);\n\n  const isDirty = useCallback(() => valueRef.current !== initialValue, [initialValue]);\n\n  const _validate = useCallback(async () => {\n    const validationResult = validate?.(valueRef.current);\n\n    if (validationResult instanceof Promise) {\n      setIsValidating(true);\n      try {\n        const result = await validationResult;\n        setIsValidating(false);\n        setError(result);\n      } catch (err) {\n        setIsValidating(false);\n        const resolvedError = errorResolver(err);\n        setError(resolvedError);\n        return resolvedError;\n      }\n    } else {\n      setError(validationResult);\n      return validationResult;\n    }\n  }, []);\n\n  const getInputProps = ({ withError = true, withFocus = true } = {}) => {\n    const onChange = getInputOnChange<T>((val) => setValue(val as any, { updateKey: false }));\n\n    const payload: any = { onChange };\n\n    if (withError) {\n      payload.error = error;\n    }\n\n    if (type === 'checkbox') {\n      payload[mode === 'controlled' ? 'checked' : 'defaultChecked'] = valueRef.current;\n    } else {\n      payload[mode === 'controlled' ? 'value' : 'defaultValue'] = valueRef.current;\n    }\n\n    if (withFocus) {\n      payload.onFocus = () => {\n        setTouched(true);\n      };\n\n      payload.onBlur = () => {\n        if (shouldValidateOnChange('', !!validateOnBlur)) {\n          _validate();\n        }\n      };\n    }\n\n    return payload;\n  };\n\n  const resetTouched = useCallback(() => setTouched(false), []);\n\n  return {\n    key,\n    getValue,\n    setValue,\n    reset,\n    getInputProps,\n\n    isValidating,\n    validate: _validate,\n\n    error,\n    setError,\n\n    isTouched,\n    isDirty,\n    resetTouched,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}