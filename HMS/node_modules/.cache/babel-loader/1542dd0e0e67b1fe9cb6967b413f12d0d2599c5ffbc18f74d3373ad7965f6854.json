{"ast":null,"code":"'use client';\n\nimport { randomId } from '@mantine/hooks';\nimport { createStore, useStore } from '@mantine/store';\nfunction getDistributedNotifications(data, defaultPosition, limit) {\n  const queue = [];\n  const notifications2 = [];\n  const count = {};\n  for (const item of data) {\n    const position = item.position || defaultPosition;\n    count[position] = count[position] || 0;\n    count[position] += 1;\n    if (count[position] <= limit) {\n      notifications2.push(item);\n    } else {\n      queue.push(item);\n    }\n  }\n  return {\n    notifications: notifications2,\n    queue\n  };\n}\nconst createNotificationsStore = () => createStore({\n  notifications: [],\n  queue: [],\n  defaultPosition: \"bottom-right\",\n  limit: 5\n});\nconst notificationsStore = createNotificationsStore();\nconst useNotifications = (store = notificationsStore) => useStore(store);\nfunction updateNotificationsState(store, update) {\n  const state = store.getState();\n  const notifications2 = update([...state.notifications, ...state.queue]);\n  const updated = getDistributedNotifications(notifications2, state.defaultPosition, state.limit);\n  store.setState({\n    notifications: updated.notifications,\n    queue: updated.queue,\n    limit: state.limit,\n    defaultPosition: state.defaultPosition\n  });\n}\nfunction showNotification(notification, store = notificationsStore) {\n  const id = notification.id || randomId();\n  updateNotificationsState(store, notifications2 => {\n    if (notification.id && notifications2.some(n => n.id === notification.id)) {\n      return notifications2;\n    }\n    return [...notifications2, {\n      ...notification,\n      id\n    }];\n  });\n  return id;\n}\nfunction hideNotification(id, store = notificationsStore) {\n  updateNotificationsState(store, notifications2 => notifications2.filter(notification => {\n    if (notification.id === id) {\n      notification.onClose?.(notification);\n      return false;\n    }\n    return true;\n  }));\n  return id;\n}\nfunction updateNotification(notification, store = notificationsStore) {\n  updateNotificationsState(store, notifications2 => notifications2.map(item => {\n    if (item.id === notification.id) {\n      return {\n        ...item,\n        ...notification\n      };\n    }\n    return item;\n  }));\n  return notification.id;\n}\nfunction cleanNotifications(store = notificationsStore) {\n  updateNotificationsState(store, () => []);\n}\nfunction cleanNotificationsQueue(store = notificationsStore) {\n  updateNotificationsState(store, notifications2 => notifications2.slice(0, store.getState().limit));\n}\nconst notifications = {\n  show: showNotification,\n  hide: hideNotification,\n  update: updateNotification,\n  clean: cleanNotifications,\n  cleanQueue: cleanNotificationsQueue,\n  updateState: updateNotificationsState\n};\nexport { cleanNotifications, cleanNotificationsQueue, createNotificationsStore, hideNotification, notifications, notificationsStore, showNotification, updateNotification, updateNotificationsState, useNotifications };","map":{"version":3,"names":["getDistributedNotifications","data","defaultPosition","limit","queue","notifications2","count","item","position","push","notifications","createNotificationsStore","createStore","notificationsStore","useNotifications","store","useStore","updateNotificationsState","update","state","getState","updated","setState","showNotification","notification","id","randomId","some","n","hideNotification","filter","onClose","updateNotification","map","cleanNotifications","cleanNotificationsQueue","slice","show","hide","clean","cleanQueue","updateState"],"sources":["E:\\HOCCODE\\HMS\\FRONTEND\\HMS\\node_modules\\@mantine\\notifications\\src\\notifications.store.ts"],"sourcesContent":["import { NotificationProps } from '@mantine/core';\nimport { randomId } from '@mantine/hooks';\nimport { createStore, MantineStore, useStore } from '@mantine/store';\n\nexport type NotificationPosition =\n  | 'top-left'\n  | 'top-right'\n  | 'top-center'\n  | 'bottom-left'\n  | 'bottom-right'\n  | 'bottom-center';\n\nexport interface NotificationData\n  extends Omit<NotificationProps, 'onClose'>,\n    Record<`data-${string}`, any> {\n  /** Notification id, can be used to close or update notification */\n  id?: string;\n\n  /** Position of the notification, if not set, the position is determined based on `position` prop on Notifications component */\n  position?: NotificationPosition;\n\n  /** Notification message, required for all notifications */\n  message: React.ReactNode;\n\n  /** Determines whether notification should be closed automatically,\n   *  number is auto close timeout in ms, overrides `autoClose` from `Notifications`\n   * */\n  autoClose?: boolean | number;\n\n  /** Called when notification closes */\n  onClose?: (props: NotificationData) => void;\n\n  /** Called when notification opens */\n  onOpen?: (props: NotificationData) => void;\n}\n\nexport interface NotificationsState {\n  notifications: NotificationData[];\n  queue: NotificationData[];\n  defaultPosition: NotificationPosition;\n  limit: number;\n}\n\nexport type NotificationsStore = MantineStore<NotificationsState>;\n\nfunction getDistributedNotifications(\n  data: NotificationData[],\n  defaultPosition: NotificationPosition,\n  limit: number\n) {\n  const queue: NotificationData[] = [];\n  const notifications: NotificationData[] = [];\n  const count: Record<string, number> = {};\n\n  for (const item of data) {\n    const position = item.position || defaultPosition;\n    count[position] = count[position] || 0;\n    count[position] += 1;\n\n    if (count[position] <= limit) {\n      notifications.push(item);\n    } else {\n      queue.push(item);\n    }\n  }\n\n  return { notifications, queue };\n}\n\nexport const createNotificationsStore = () =>\n  createStore<NotificationsState>({\n    notifications: [],\n    queue: [],\n    defaultPosition: 'bottom-right',\n    limit: 5,\n  });\n\nexport const notificationsStore = createNotificationsStore();\nexport const useNotifications = (store: NotificationsStore = notificationsStore) => useStore(store);\n\nexport function updateNotificationsState(\n  store: NotificationsStore,\n  update: (notifications: NotificationData[]) => NotificationData[]\n) {\n  const state = store.getState();\n  const notifications = update([...state.notifications, ...state.queue]);\n  const updated = getDistributedNotifications(notifications, state.defaultPosition, state.limit);\n\n  store.setState({\n    notifications: updated.notifications,\n    queue: updated.queue,\n    limit: state.limit,\n    defaultPosition: state.defaultPosition,\n  });\n}\n\nexport function showNotification(\n  notification: NotificationData,\n  store: NotificationsStore = notificationsStore\n) {\n  const id = notification.id || randomId();\n\n  updateNotificationsState(store, (notifications) => {\n    if (notification.id && notifications.some((n) => n.id === notification.id)) {\n      return notifications;\n    }\n\n    return [...notifications, { ...notification, id }];\n  });\n\n  return id;\n}\n\nexport function hideNotification(id: string, store: NotificationsStore = notificationsStore) {\n  updateNotificationsState(store, (notifications) =>\n    notifications.filter((notification) => {\n      if (notification.id === id) {\n        notification.onClose?.(notification);\n        return false;\n      }\n\n      return true;\n    })\n  );\n\n  return id;\n}\n\nexport function updateNotification(\n  notification: NotificationData,\n  store: NotificationsStore = notificationsStore\n) {\n  updateNotificationsState(store, (notifications) =>\n    notifications.map((item) => {\n      if (item.id === notification.id) {\n        return { ...item, ...notification };\n      }\n\n      return item;\n    })\n  );\n\n  return notification.id;\n}\n\nexport function cleanNotifications(store: NotificationsStore = notificationsStore) {\n  updateNotificationsState(store, () => []);\n}\n\nexport function cleanNotificationsQueue(store: NotificationsStore = notificationsStore) {\n  updateNotificationsState(store, (notifications) =>\n    notifications.slice(0, store.getState().limit)\n  );\n}\n\nexport const notifications = {\n  show: showNotification,\n  hide: hideNotification,\n  update: updateNotification,\n  clean: cleanNotifications,\n  cleanQueue: cleanNotificationsQueue,\n  updateState: updateNotificationsState,\n} as const;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}