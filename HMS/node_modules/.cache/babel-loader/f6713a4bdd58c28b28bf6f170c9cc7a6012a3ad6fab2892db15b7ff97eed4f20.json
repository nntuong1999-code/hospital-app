{"ast":null,"code":"'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useDelayGroup, useFloating, autoUpdate, useInteractions, useHover, useFocus, useRole, useDismiss, offset, shift, flip, arrow, inline } from '@floating-ui/react';\nimport { useId, useDidUpdate } from '@mantine/hooks';\nimport { useTooltipGroupContext } from './TooltipGroup/TooltipGroup.context.mjs';\nfunction getDefaultMiddlewares(middlewares) {\n  if (middlewares === void 0) {\n    return {\n      shift: true,\n      flip: true\n    };\n  }\n  const result = {\n    ...middlewares\n  };\n  if (middlewares.shift === void 0) {\n    result.shift = true;\n  }\n  if (middlewares.flip === void 0) {\n    result.flip = true;\n  }\n  return result;\n}\nfunction getTooltipMiddlewares(settings) {\n  const middlewaresOptions = getDefaultMiddlewares(settings.middlewares);\n  const middlewares = [offset(settings.offset)];\n  if (middlewaresOptions.shift) {\n    middlewares.push(shift(typeof middlewaresOptions.shift === \"boolean\" ? {\n      padding: 8\n    } : {\n      padding: 8,\n      ...middlewaresOptions.shift\n    }));\n  }\n  if (middlewaresOptions.flip) {\n    middlewares.push(typeof middlewaresOptions.flip === \"boolean\" ? flip() : flip(middlewaresOptions.flip));\n  }\n  middlewares.push(arrow({\n    element: settings.arrowRef,\n    padding: settings.arrowOffset\n  }));\n  if (middlewaresOptions.inline) {\n    middlewares.push(typeof middlewaresOptions.inline === \"boolean\" ? inline() : inline(middlewaresOptions.inline));\n  } else if (settings.inline) {\n    middlewares.push(inline());\n  }\n  return middlewares;\n}\nfunction useTooltip(settings) {\n  const [uncontrolledOpened, setUncontrolledOpened] = useState(settings.defaultOpened);\n  const controlled = typeof settings.opened === \"boolean\";\n  const opened = controlled ? settings.opened : uncontrolledOpened;\n  const withinGroup = useTooltipGroupContext();\n  const uid = useId();\n  const onChange = useCallback(_opened => {\n    setUncontrolledOpened(_opened);\n    if (_opened) {\n      setCurrentId(uid);\n    }\n  }, [uid]);\n  const {\n    x,\n    y,\n    context,\n    refs,\n    placement,\n    middlewareData: {\n      arrow: {\n        x: arrowX,\n        y: arrowY\n      } = {}\n    }\n  } = useFloating({\n    strategy: settings.strategy,\n    placement: settings.position,\n    open: opened,\n    onOpenChange: onChange,\n    middleware: getTooltipMiddlewares(settings),\n    whileElementsMounted: autoUpdate\n  });\n  const {\n    delay: groupDelay,\n    currentId,\n    setCurrentId\n  } = useDelayGroup(context, {\n    id: uid\n  });\n  const {\n    getReferenceProps,\n    getFloatingProps\n  } = useInteractions([useHover(context, {\n    enabled: settings.events?.hover,\n    delay: withinGroup ? groupDelay : {\n      open: settings.openDelay,\n      close: settings.closeDelay\n    },\n    mouseOnly: !settings.events?.touch\n  }), useFocus(context, {\n    enabled: settings.events?.focus,\n    visibleOnly: true\n  }), useRole(context, {\n    role: \"tooltip\"\n  }),\n  // Cannot be used with controlled tooltip, page jumps\n  useDismiss(context, {\n    enabled: typeof settings.opened === \"undefined\"\n  })]);\n  useDidUpdate(() => {\n    settings.onPositionChange?.(placement);\n  }, [placement]);\n  const isGroupPhase = opened && currentId && currentId !== uid;\n  return {\n    x,\n    y,\n    arrowX,\n    arrowY,\n    reference: refs.setReference,\n    floating: refs.setFloating,\n    getFloatingProps,\n    getReferenceProps,\n    isGroupPhase,\n    opened,\n    placement\n  };\n}\nexport { useTooltip };","map":{"version":3,"names":["getDefaultMiddlewares","middlewares","shift","flip","result","getTooltipMiddlewares","settings","middlewaresOptions","offset","push","padding","arrow","element","arrowRef","arrowOffset","inline","useTooltip","uncontrolledOpened","setUncontrolledOpened","useState","defaultOpened","controlled","opened","withinGroup","useTooltipGroupContext","uid","useId","onChange","useCallback","_opened","setCurrentId","x","y","context","refs","placement","middlewareData","arrowX","arrowY","useFloating","strategy","position","open","onOpenChange","middleware","whileElementsMounted","autoUpdate","delay","groupDelay","currentId","useDelayGroup","id","getReferenceProps","getFloatingProps","useInteractions","useHover","enabled","events","hover","openDelay","close","closeDelay","mouseOnly","touch","useFocus","focus","visibleOnly","useRole","role","useDismiss","useDidUpdate","onPositionChange","isGroupPhase","reference","setReference","floating","setFloating"],"sources":["E:\\HOCCODE\\HMS\\FRONTEND\\HMS\\node_modules\\@mantine\\core\\src\\components\\Tooltip\\use-tooltip.ts"],"sourcesContent":["import { useCallback, useState } from 'react';\nimport {\n  arrow,\n  autoUpdate,\n  flip,\n  inline,\n  offset,\n  shift,\n  useDelayGroup,\n  useDismiss,\n  useFloating,\n  useFocus,\n  useHover,\n  useInteractions,\n  useRole,\n  type Middleware,\n} from '@floating-ui/react';\nimport { useDidUpdate, useId } from '@mantine/hooks';\nimport { FloatingAxesOffsets, FloatingPosition, FloatingStrategy } from '../../utils/Floating';\nimport { type TooltipMiddlewares } from './Tooltip.types';\nimport { useTooltipGroupContext } from './TooltipGroup/TooltipGroup.context';\n\ninterface UseTooltip {\n  position: FloatingPosition;\n  closeDelay?: number;\n  openDelay?: number;\n  onPositionChange?: (position: FloatingPosition) => void;\n  opened?: boolean;\n  defaultOpened?: boolean;\n  offset: number | FloatingAxesOffsets;\n  arrowRef?: React.RefObject<HTMLDivElement | null>;\n  arrowOffset?: number;\n  events?: { hover: boolean; focus: boolean; touch: boolean };\n  positionDependencies: any[];\n  inline?: boolean;\n  strategy?: FloatingStrategy;\n  middlewares?: TooltipMiddlewares;\n}\n\nfunction getDefaultMiddlewares(middlewares: TooltipMiddlewares | undefined): TooltipMiddlewares {\n  if (middlewares === undefined) {\n    return { shift: true, flip: true };\n  }\n\n  const result = { ...middlewares };\n  if (middlewares.shift === undefined) {\n    result.shift = true;\n  }\n\n  if (middlewares.flip === undefined) {\n    result.flip = true;\n  }\n\n  return result;\n}\n\nfunction getTooltipMiddlewares(settings: UseTooltip) {\n  const middlewaresOptions = getDefaultMiddlewares(settings.middlewares);\n  const middlewares: Middleware[] = [offset(settings.offset)];\n\n  if (middlewaresOptions.shift) {\n    middlewares.push(\n      shift(\n        typeof middlewaresOptions.shift === 'boolean'\n          ? { padding: 8 }\n          : { padding: 8, ...middlewaresOptions.shift }\n      )\n    );\n  }\n\n  if (middlewaresOptions.flip) {\n    middlewares.push(\n      typeof middlewaresOptions.flip === 'boolean' ? flip() : flip(middlewaresOptions.flip)\n    );\n  }\n\n  middlewares.push(arrow({ element: settings.arrowRef!, padding: settings.arrowOffset }));\n\n  if (middlewaresOptions.inline) {\n    middlewares.push(\n      typeof middlewaresOptions.inline === 'boolean' ? inline() : inline(middlewaresOptions.inline)\n    );\n  } else if (settings.inline) {\n    middlewares.push(inline());\n  }\n\n  return middlewares;\n}\n\nexport function useTooltip(settings: UseTooltip) {\n  const [uncontrolledOpened, setUncontrolledOpened] = useState(settings.defaultOpened);\n  const controlled = typeof settings.opened === 'boolean';\n  const opened = controlled ? settings.opened : uncontrolledOpened;\n  const withinGroup = useTooltipGroupContext();\n  const uid = useId();\n\n  const onChange = useCallback(\n    (_opened: boolean) => {\n      setUncontrolledOpened(_opened);\n\n      if (_opened) {\n        setCurrentId(uid);\n      }\n    },\n    [uid]\n  );\n\n  const {\n    x,\n    y,\n    context,\n    refs,\n    placement,\n    middlewareData: { arrow: { x: arrowX, y: arrowY } = {} },\n  } = useFloating({\n    strategy: settings.strategy,\n    placement: settings.position,\n    open: opened,\n    onOpenChange: onChange,\n    middleware: getTooltipMiddlewares(settings),\n    whileElementsMounted: autoUpdate,\n  });\n\n  const { delay: groupDelay, currentId, setCurrentId } = useDelayGroup(context, { id: uid });\n\n  const { getReferenceProps, getFloatingProps } = useInteractions([\n    useHover(context, {\n      enabled: settings.events?.hover,\n      delay: withinGroup ? groupDelay : { open: settings.openDelay, close: settings.closeDelay },\n      mouseOnly: !settings.events?.touch,\n    }),\n    useFocus(context, { enabled: settings.events?.focus, visibleOnly: true }),\n    useRole(context, { role: 'tooltip' }),\n    // Cannot be used with controlled tooltip, page jumps\n    useDismiss(context, { enabled: typeof settings.opened === 'undefined' }),\n  ]);\n\n  useDidUpdate(() => {\n    settings.onPositionChange?.(placement);\n  }, [placement]);\n\n  const isGroupPhase = opened && currentId && currentId !== uid;\n\n  return {\n    x,\n    y,\n    arrowX,\n    arrowY,\n    reference: refs.setReference,\n    floating: refs.setFloating,\n    getFloatingProps,\n    getReferenceProps,\n    isGroupPhase,\n    opened,\n    placement,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}