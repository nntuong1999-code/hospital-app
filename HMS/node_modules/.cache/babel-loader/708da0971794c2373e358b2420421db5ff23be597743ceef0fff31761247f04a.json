{"ast":null,"code":"'use client';\n\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useState, useEffect } from 'react';\nimport { useDebouncedCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\nimport { composeEventHandlers } from '../utils/compose-event-handlers.mjs';\nimport { ScrollAreaScrollbarVisible } from './ScrollAreaScrollbarVisible.mjs';\nconst ScrollAreaScrollbarScroll = forwardRef((props, red) => {\n  const {\n    forceMount,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext();\n  const isHorizontal = props.orientation === \"horizontal\";\n  const [state, setState] = useState(\"hidden\");\n  const debounceScrollEnd = useDebouncedCallback(() => setState(\"idle\"), 100);\n  useEffect(() => {\n    if (state === \"idle\") {\n      const hideTimer = window.setTimeout(() => setState(\"hidden\"), context.scrollHideDelay);\n      return () => window.clearTimeout(hideTimer);\n    }\n    return void 0;\n  }, [state, context.scrollHideDelay]);\n  useEffect(() => {\n    const {\n      viewport\n    } = context;\n    const scrollDirection = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n    if (viewport) {\n      let prevScrollPos = viewport[scrollDirection];\n      const handleScroll = () => {\n        const scrollPos = viewport[scrollDirection];\n        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;\n        if (hasScrollInDirectionChanged) {\n          setState(\"scrolling\");\n          debounceScrollEnd();\n        }\n        prevScrollPos = scrollPos;\n      };\n      viewport.addEventListener(\"scroll\", handleScroll);\n      return () => viewport.removeEventListener(\"scroll\", handleScroll);\n    }\n    return void 0;\n  }, [context.viewport, isHorizontal, debounceScrollEnd]);\n  if (forceMount || state !== \"hidden\") {\n    return /* @__PURE__ */jsx(ScrollAreaScrollbarVisible, {\n      \"data-state\": state === \"hidden\" ? \"hidden\" : \"visible\",\n      ...scrollbarProps,\n      ref: red,\n      onPointerEnter: composeEventHandlers(props.onPointerEnter, () => setState(\"interacting\")),\n      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => setState(\"idle\"))\n    });\n  }\n  return null;\n});\nexport { ScrollAreaScrollbarScroll };","map":{"version":3,"names":["ScrollAreaScrollbarScroll","forwardRef","props","red","forceMount","scrollbarProps","context","useScrollAreaContext","isHorizontal","orientation","state","setState","useState","debounceScrollEnd","useDebouncedCallback","useEffect","hideTimer","window","setTimeout","scrollHideDelay","clearTimeout","viewport","scrollDirection","prevScrollPos","handleScroll","scrollPos","hasScrollInDirectionChanged","addEventListener","removeEventListener","jsx","ScrollAreaScrollbarVisible","ref","onPointerEnter","composeEventHandlers","onPointerLeave"],"sources":["E:\\HOCCODE\\SMS\\FRONTEND\\hospitalapp\\node_modules\\@mantine\\core\\src\\components\\ScrollArea\\ScrollAreaScrollbar\\ScrollAreaScrollbarScroll.tsx"],"sourcesContent":["import { forwardRef, useEffect, useState } from 'react';\nimport { useDebouncedCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { composeEventHandlers } from '../utils';\nimport {\n  ScrollAreaScrollbarVisible,\n  ScrollAreaScrollbarVisibleProps,\n} from './ScrollAreaScrollbarVisible';\n\ninterface ScrollAreaScrollbarScrollProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nexport const ScrollAreaScrollbarScroll = forwardRef<HTMLDivElement, ScrollAreaScrollbarScrollProps>(\n  (props, red) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext();\n    const isHorizontal = props.orientation === 'horizontal';\n    const [state, setState] = useState<'hidden' | 'idle' | 'interacting' | 'scrolling'>('hidden');\n    const debounceScrollEnd = useDebouncedCallback(() => setState('idle'), 100);\n\n    useEffect(() => {\n      if (state === 'idle') {\n        const hideTimer = window.setTimeout(() => setState('hidden'), context.scrollHideDelay);\n        return () => window.clearTimeout(hideTimer);\n      }\n\n      return undefined;\n    }, [state, context.scrollHideDelay]);\n\n    useEffect(() => {\n      const { viewport } = context;\n      const scrollDirection = isHorizontal ? 'scrollLeft' : 'scrollTop';\n\n      if (viewport) {\n        let prevScrollPos = viewport[scrollDirection];\n        const handleScroll = () => {\n          const scrollPos = viewport[scrollDirection];\n          const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;\n          if (hasScrollInDirectionChanged) {\n            setState('scrolling');\n            debounceScrollEnd();\n          }\n          prevScrollPos = scrollPos;\n        };\n        viewport.addEventListener('scroll', handleScroll);\n        return () => viewport.removeEventListener('scroll', handleScroll);\n      }\n\n      return undefined;\n    }, [context.viewport, isHorizontal, debounceScrollEnd]);\n\n    if (forceMount || state !== 'hidden') {\n      return (\n        <ScrollAreaScrollbarVisible\n          data-state={state === 'hidden' ? 'hidden' : 'visible'}\n          {...scrollbarProps}\n          ref={red}\n          onPointerEnter={composeEventHandlers(props.onPointerEnter, () => setState('interacting'))}\n          onPointerLeave={composeEventHandlers(props.onPointerLeave, () => setState('idle'))}\n        />\n      );\n    }\n\n    return null;\n  }\n);\n"],"mappings":";;;;;;;;AAaO,MAAMA,yBAAA,GAA4BC,UAAA,CACvC,CAACC,KAAA,EAAOC,GAAA,KAAQ;EACd,MAAM;IAAEC,UAAA;IAAY,GAAGC;EAAA,CAAe,GAAIH,KAAA;EAC1C,MAAMI,OAAA,GAAUC,oBAAA,EAAqB;EACrC,MAAMC,YAAA,GAAeN,KAAA,CAAMO,WAAA,KAAgB;EAC3C,MAAM,CAACC,KAAA,EAAOC,QAAQ,IAAIC,QAAA,CAA0D,QAAQ;EAC5F,MAAMC,iBAAA,GAAoBC,oBAAA,CAAqB,MAAMH,QAAA,CAAS,MAAM,GAAG,GAAG;EAE1EI,SAAA,CAAU,MAAM;IACd,IAAIL,KAAA,KAAU,QAAQ;MACpB,MAAMM,SAAA,GAAYC,MAAA,CAAOC,UAAA,CAAW,MAAMP,QAAA,CAAS,QAAQ,GAAGL,OAAA,CAAQa,eAAe;MACrF,OAAO,MAAMF,MAAA,CAAOG,YAAA,CAAaJ,SAAS;IAC5C;IAEA,OAAO;EACT,GAAG,CAACN,KAAA,EAAOJ,OAAA,CAAQa,eAAe,CAAC;EAEnCJ,SAAA,CAAU,MAAM;IACd,MAAM;MAAEM;IAAA,CAAS,GAAIf,OAAA;IACrB,MAAMgB,eAAA,GAAkBd,YAAA,GAAe,eAAe;IAEtD,IAAIa,QAAA,EAAU;MACZ,IAAIE,aAAA,GAAgBF,QAAA,CAASC,eAAe;MAC5C,MAAME,YAAA,GAAeA,CAAA,KAAM;QACzB,MAAMC,SAAA,GAAYJ,QAAA,CAASC,eAAe;QAC1C,MAAMI,2BAAA,GAA8BH,aAAA,KAAkBE,SAAA;QACtD,IAAIC,2BAAA,EAA6B;UAC/Bf,QAAA,CAAS,WAAW;UACpBE,iBAAA,EAAkB;QACpB;QACAU,aAAA,GAAgBE,SAAA;MAClB;MACAJ,QAAA,CAASM,gBAAA,CAAiB,UAAUH,YAAY;MAChD,OAAO,MAAMH,QAAA,CAASO,mBAAA,CAAoB,UAAUJ,YAAY;IAClE;IAEA,OAAO;EACT,GAAG,CAAClB,OAAA,CAAQe,QAAA,EAAUb,YAAA,EAAcK,iBAAiB,CAAC;EAEtD,IAAIT,UAAA,IAAcM,KAAA,KAAU,UAAU;IACpC,sBACEmB,GAAA,CAACC,0BAAA;MACC,cAAYpB,KAAA,KAAU,WAAW,WAAW;MAC3C,GAAGL,cAAA;MACJ0B,GAAA,EAAK5B,GAAA;MACL6B,cAAA,EAAgBC,oBAAA,CAAqB/B,KAAA,CAAM8B,cAAA,EAAgB,MAAMrB,QAAA,CAAS,aAAa,CAAC;MACxFuB,cAAA,EAAgBD,oBAAA,CAAqB/B,KAAA,CAAMgC,cAAA,EAAgB,MAAMvB,QAAA,CAAS,MAAM,CAAC;IAAA,EACnF;EAEJ;EAEA,OAAO;AACT,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}