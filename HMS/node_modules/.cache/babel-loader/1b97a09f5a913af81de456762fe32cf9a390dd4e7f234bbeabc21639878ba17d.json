{"ast":null,"code":"'use client';\n\nconst TABBABLE_NODES = /input|select|textarea|button|object/;\nconst FOCUS_SELECTOR = \"a, input, select, textarea, button, object, [tabindex]\";\nfunction hidden(element) {\n  if (process.env.NODE_ENV === \"test\") {\n    return false;\n  }\n  return element.style.display === \"none\";\n}\nfunction visible(element) {\n  const isHidden = element.getAttribute(\"aria-hidden\") || element.getAttribute(\"hidden\") || element.getAttribute(\"type\") === \"hidden\";\n  if (isHidden) {\n    return false;\n  }\n  let parentElement = element;\n  while (parentElement) {\n    if (parentElement === document.body || parentElement.nodeType === 11) {\n      break;\n    }\n    if (hidden(parentElement)) {\n      return false;\n    }\n    parentElement = parentElement.parentNode;\n  }\n  return true;\n}\nfunction getElementTabIndex(element) {\n  let tabIndex = element.getAttribute(\"tabindex\");\n  if (tabIndex === null) {\n    tabIndex = void 0;\n  }\n  return parseInt(tabIndex, 10);\n}\nfunction focusable(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  const isTabIndexNotNaN = !Number.isNaN(getElementTabIndex(element));\n  const res =\n  // @ts-expect-error function accepts any html element but if it is a button, it should not be disabled to trigger the condition\n  TABBABLE_NODES.test(nodeName) && !element.disabled || (element instanceof HTMLAnchorElement ? element.href || isTabIndexNotNaN : isTabIndexNotNaN);\n  return res && visible(element);\n}\nfunction tabbable(element) {\n  const tabIndex = getElementTabIndex(element);\n  const isTabIndexNaN = Number.isNaN(tabIndex);\n  return (isTabIndexNaN || tabIndex >= 0) && focusable(element);\n}\nfunction findTabbableDescendants(element) {\n  return Array.from(element.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);\n}\nexport { FOCUS_SELECTOR, findTabbableDescendants, focusable, tabbable };","map":{"version":3,"names":["TABBABLE_NODES","FOCUS_SELECTOR","hidden","element","process","env","NODE_ENV","style","display","visible","isHidden","getAttribute","parentElement","document","body","nodeType","parentNode","getElementTabIndex","tabIndex","parseInt","focusable","nodeName","toLowerCase","isTabIndexNotNaN","Number","isNaN","res","test","disabled","HTMLAnchorElement","href","tabbable","isTabIndexNaN","findTabbableDescendants","Array","from","querySelectorAll","filter"],"sources":["E:\\HOCCODE\\HMS\\FRONTEND\\HMS\\node_modules\\@mantine\\hooks\\src\\use-focus-trap\\tabbable.ts"],"sourcesContent":["const TABBABLE_NODES = /input|select|textarea|button|object/;\nexport const FOCUS_SELECTOR = 'a, input, select, textarea, button, object, [tabindex]';\n\nfunction hidden(element: HTMLElement) {\n  if (process.env.NODE_ENV === 'test') {\n    return false;\n  }\n\n  return element.style.display === 'none';\n}\n\nfunction visible(element: HTMLElement) {\n  const isHidden =\n    element.getAttribute('aria-hidden') ||\n    element.getAttribute('hidden') ||\n    element.getAttribute('type') === 'hidden';\n\n  if (isHidden) {\n    return false;\n  }\n\n  let parentElement: HTMLElement = element;\n  while (parentElement) {\n    if (parentElement === document.body || parentElement.nodeType === 11) {\n      break;\n    }\n\n    if (hidden(parentElement)) {\n      return false;\n    }\n\n    parentElement = parentElement.parentNode as HTMLElement;\n  }\n\n  return true;\n}\n\nfunction getElementTabIndex(element: HTMLElement) {\n  let tabIndex: string | null | undefined = element.getAttribute('tabindex');\n  if (tabIndex === null) {\n    tabIndex = undefined;\n  }\n  return parseInt(tabIndex as string, 10);\n}\n\nexport function focusable(element: HTMLElement) {\n  const nodeName = element.nodeName.toLowerCase();\n  const isTabIndexNotNaN = !Number.isNaN(getElementTabIndex(element));\n  const res =\n    // @ts-expect-error function accepts any html element but if it is a button, it should not be disabled to trigger the condition\n    (TABBABLE_NODES.test(nodeName) && !element.disabled) ||\n    (element instanceof HTMLAnchorElement ? element.href || isTabIndexNotNaN : isTabIndexNotNaN);\n\n  return res && visible(element);\n}\n\nexport function tabbable(element: HTMLElement) {\n  const tabIndex = getElementTabIndex(element);\n  const isTabIndexNaN = Number.isNaN(tabIndex);\n  return (isTabIndexNaN || tabIndex >= 0) && focusable(element);\n}\n\nexport function findTabbableDescendants(element: HTMLElement): HTMLElement[] {\n  return Array.from(element.querySelectorAll<HTMLElement>(FOCUS_SELECTOR)).filter(tabbable);\n}\n"],"mappings":";;AAAA,MAAMA,cAAA,GAAiB;AAChB,MAAMC,cAAA,GAAiB;AAE9B,SAASC,OAAOC,OAAA,EAAsB;EACpC,IAAIC,OAAA,CAAQC,GAAA,CAAIC,QAAA,KAAa,QAAQ;IACnC,OAAO;EACT;EAEA,OAAOH,OAAA,CAAQI,KAAA,CAAMC,OAAA,KAAY;AACnC;AAEA,SAASC,QAAQN,OAAA,EAAsB;EACrC,MAAMO,QAAA,GACJP,OAAA,CAAQQ,YAAA,CAAa,aAAa,KAClCR,OAAA,CAAQQ,YAAA,CAAa,QAAQ,KAC7BR,OAAA,CAAQQ,YAAA,CAAa,MAAM,MAAM;EAEnC,IAAID,QAAA,EAAU;IACZ,OAAO;EACT;EAEA,IAAIE,aAAA,GAA6BT,OAAA;EACjC,OAAOS,aAAA,EAAe;IACpB,IAAIA,aAAA,KAAkBC,QAAA,CAASC,IAAA,IAAQF,aAAA,CAAcG,QAAA,KAAa,IAAI;MACpE;IACF;IAEA,IAAIb,MAAA,CAAOU,aAAa,GAAG;MACzB,OAAO;IACT;IAEAA,aAAA,GAAgBA,aAAA,CAAcI,UAAA;EAChC;EAEA,OAAO;AACT;AAEA,SAASC,mBAAmBd,OAAA,EAAsB;EAChD,IAAIe,QAAA,GAAsCf,OAAA,CAAQQ,YAAA,CAAa,UAAU;EACzE,IAAIO,QAAA,KAAa,MAAM;IACrBA,QAAA,GAAW;EACb;EACA,OAAOC,QAAA,CAASD,QAAA,EAAoB,EAAE;AACxC;AAEO,SAASE,UAAUjB,OAAA,EAAsB;EAC9C,MAAMkB,QAAA,GAAWlB,OAAA,CAAQkB,QAAA,CAASC,WAAA,EAAY;EAC9C,MAAMC,gBAAA,GAAmB,CAACC,MAAA,CAAOC,KAAA,CAAMR,kBAAA,CAAmBd,OAAO,CAAC;EAClE,MAAMuB,GAAA;EAAA;EAEH1B,cAAA,CAAe2B,IAAA,CAAKN,QAAQ,KAAK,CAAClB,OAAA,CAAQyB,QAAA,KAC1CzB,OAAA,YAAmB0B,iBAAA,GAAoB1B,OAAA,CAAQ2B,IAAA,IAAQP,gBAAA,GAAmBA,gBAAA;EAE7E,OAAOG,GAAA,IAAOjB,OAAA,CAAQN,OAAO;AAC/B;AAEO,SAAS4B,SAAS5B,OAAA,EAAsB;EAC7C,MAAMe,QAAA,GAAWD,kBAAA,CAAmBd,OAAO;EAC3C,MAAM6B,aAAA,GAAgBR,MAAA,CAAOC,KAAA,CAAMP,QAAQ;EAC3C,QAAQc,aAAA,IAAiBd,QAAA,IAAY,MAAME,SAAA,CAAUjB,OAAO;AAC9D;AAEO,SAAS8B,wBAAwB9B,OAAA,EAAqC;EAC3E,OAAO+B,KAAA,CAAMC,IAAA,CAAKhC,OAAA,CAAQiC,gBAAA,CAA8BnC,cAAc,CAAC,EAAEoC,MAAA,CAAON,QAAQ;AAC1F","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}