{"ast":null,"code":"'use client';\n\nimport { clearListState } from './clear-list-state.mjs';\nfunction getIndexFromKeyAfterPath(key, path) {\n  const split = key.substring(path.length + 1).split(\".\")[0];\n  return parseInt(split, 10);\n}\nfunction changeErrorIndices(path, index, errors, change) {\n  if (index === void 0) {\n    return errors;\n  }\n  const pathString = `${String(path)}`;\n  let clearedErrors = errors;\n  if (change === -1) {\n    clearedErrors = clearListState(`${pathString}.${index}`, clearedErrors);\n  }\n  const cloned = {\n    ...clearedErrors\n  };\n  const changedKeys = /* @__PURE__ */new Set();\n  Object.entries(clearedErrors).filter(([key]) => {\n    if (!key.startsWith(`${pathString}.`)) {\n      return false;\n    }\n    const currIndex = getIndexFromKeyAfterPath(key, pathString);\n    if (Number.isNaN(currIndex)) {\n      return false;\n    }\n    return currIndex >= index;\n  }).forEach(([key, value]) => {\n    const currIndex = getIndexFromKeyAfterPath(key, pathString);\n    const newKey = key.replace(`${pathString}.${currIndex}`, `${pathString}.${currIndex + change}`);\n    cloned[newKey] = value;\n    changedKeys.add(newKey);\n    if (!changedKeys.has(key)) {\n      delete cloned[key];\n    }\n  });\n  return cloned;\n}\nexport { changeErrorIndices };","map":{"version":3,"names":["getIndexFromKeyAfterPath","key","path","split","substring","length","parseInt","changeErrorIndices","index","errors","change","pathString","String","clearedErrors","clearListState","cloned","changedKeys","Set","Object","entries","filter","startsWith","currIndex","Number","isNaN","forEach","value","newKey","replace","add","has"],"sources":["E:\\HOCCODE\\HMS\\FRONTEND\\HMS\\node_modules\\@mantine\\form\\src\\lists\\change-error-indices.ts"],"sourcesContent":["import { clearListState } from './clear-list-state';\n\n/**\n * Gets the part of the key after the path which can be an index\n */\nfunction getIndexFromKeyAfterPath(key: string, path: string): number {\n  const split = key.substring(path.length + 1).split('.')[0];\n  return parseInt(split, 10);\n}\n\n/**\n * Changes the indices of every error that is after the given `index` with the given `change` at the given `path`.\n * This requires that the errors are in the format of `path.index` and that the index is a number.\n */\nexport function changeErrorIndices<T extends Record<PropertyKey, any>>(\n  path: PropertyKey,\n  index: number | undefined,\n  errors: T,\n  change: 1 | -1\n): T {\n  if (index === undefined) {\n    return errors;\n  }\n  const pathString = `${String(path)}`;\n  let clearedErrors = errors;\n  // Remove all errors if the corresponding item was removed\n  if (change === -1) {\n    clearedErrors = clearListState(`${pathString}.${index}`, clearedErrors);\n  }\n\n  const cloned = { ...clearedErrors };\n  const changedKeys = new Set<string>();\n  Object.entries(clearedErrors)\n    .filter(([key]) => {\n      if (!key.startsWith(`${pathString}.`)) {\n        return false;\n      }\n      const currIndex = getIndexFromKeyAfterPath(key, pathString);\n      if (Number.isNaN(currIndex)) {\n        return false;\n      }\n      return currIndex >= index;\n    })\n    .forEach(([key, value]) => {\n      const currIndex = getIndexFromKeyAfterPath(key, pathString);\n\n      const newKey: keyof T = key.replace(\n        `${pathString}.${currIndex}`,\n        `${pathString}.${currIndex + change}`\n      );\n      cloned[newKey] = value;\n      changedKeys.add(newKey);\n      if (!changedKeys.has(key)) {\n        delete cloned[key];\n      }\n    });\n\n  return cloned;\n}\n"],"mappings":";;;AAKA,SAASA,yBAAyBC,GAAA,EAAaC,IAAA,EAAsB;EACnE,MAAMC,KAAA,GAAQF,GAAA,CAAIG,SAAA,CAAUF,IAAA,CAAKG,MAAA,GAAS,CAAC,EAAEF,KAAA,CAAM,GAAG,EAAE,CAAC;EACzD,OAAOG,QAAA,CAASH,KAAA,EAAO,EAAE;AAC3B;AAMO,SAASI,mBACdL,IAAA,EACAM,KAAA,EACAC,MAAA,EACAC,MAAA,EACG;EACH,IAAIF,KAAA,KAAU,QAAW;IACvB,OAAOC,MAAA;EACT;EACA,MAAME,UAAA,GAAa,GAAGC,MAAA,CAAOV,IAAI,CAAC;EAClC,IAAIW,aAAA,GAAgBJ,MAAA;EAEpB,IAAIC,MAAA,KAAW,IAAI;IACjBG,aAAA,GAAgBC,cAAA,CAAe,GAAGH,UAAU,IAAIH,KAAK,IAAIK,aAAa;EACxE;EAEA,MAAME,MAAA,GAAS;IAAE,GAAGF;EAAA,CAAc;EAClC,MAAMG,WAAA,sBAAkBC,GAAA,EAAY;EACpCC,MAAA,CAAOC,OAAA,CAAQN,aAAa,EACzBO,MAAA,CAAO,CAAC,CAACnB,GAAG,MAAM;IACjB,IAAI,CAACA,GAAA,CAAIoB,UAAA,CAAW,GAAGV,UAAU,GAAG,GAAG;MACrC,OAAO;IACT;IACA,MAAMW,SAAA,GAAYtB,wBAAA,CAAyBC,GAAA,EAAKU,UAAU;IAC1D,IAAIY,MAAA,CAAOC,KAAA,CAAMF,SAAS,GAAG;MAC3B,OAAO;IACT;IACA,OAAOA,SAAA,IAAad,KAAA;EACtB,CAAC,EACAiB,OAAA,CAAQ,CAAC,CAACxB,GAAA,EAAKyB,KAAK,MAAM;IACzB,MAAMJ,SAAA,GAAYtB,wBAAA,CAAyBC,GAAA,EAAKU,UAAU;IAE1D,MAAMgB,MAAA,GAAkB1B,GAAA,CAAI2B,OAAA,CAC1B,GAAGjB,UAAU,IAAIW,SAAS,IAC1B,GAAGX,UAAU,IAAIW,SAAA,GAAYZ,MAAM,GACrC;IACAK,MAAA,CAAOY,MAAM,IAAID,KAAA;IACjBV,WAAA,CAAYa,GAAA,CAAIF,MAAM;IACtB,IAAI,CAACX,WAAA,CAAYc,GAAA,CAAI7B,GAAG,GAAG;MACzB,OAAOc,MAAA,CAAOd,GAAG;IACnB;EACF,CAAC;EAEH,OAAOc,MAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}