{"ast":null,"code":"'use client';\n\nimport { useRef, useState, useEffect, useCallback } from 'react';\nimport { clamp } from '../utils/clamp/clamp.mjs';\nfunction clampUseMovePosition(position) {\n  return {\n    x: clamp(position.x, 0, 1),\n    y: clamp(position.y, 0, 1)\n  };\n}\nfunction useMove(onChange, handlers, dir = \"ltr\") {\n  const mounted = useRef(false);\n  const isSliding = useRef(false);\n  const frame = useRef(0);\n  const [active, setActive] = useState(false);\n  const cleanupRef = useRef(null);\n  useEffect(() => {\n    mounted.current = true;\n  }, []);\n  const refCallback = useCallback(node => {\n    if (cleanupRef.current) {\n      cleanupRef.current();\n      cleanupRef.current = null;\n    }\n    if (!node) {\n      return;\n    }\n    const onScrub = ({\n      x,\n      y\n    }) => {\n      cancelAnimationFrame(frame.current);\n      frame.current = requestAnimationFrame(() => {\n        if (mounted.current && node) {\n          node.style.userSelect = \"none\";\n          const rect = node.getBoundingClientRect();\n          if (rect.width && rect.height) {\n            const _x = clamp((x - rect.left) / rect.width, 0, 1);\n            onChange({\n              x: dir === \"ltr\" ? _x : 1 - _x,\n              y: clamp((y - rect.top) / rect.height, 0, 1)\n            });\n          }\n        }\n      });\n    };\n    const bindEvents = () => {\n      document.addEventListener(\"mousemove\", onMouseMove);\n      document.addEventListener(\"mouseup\", stopScrubbing);\n      document.addEventListener(\"touchmove\", onTouchMove, {\n        passive: false\n      });\n      document.addEventListener(\"touchend\", stopScrubbing);\n    };\n    const unbindEvents = () => {\n      document.removeEventListener(\"mousemove\", onMouseMove);\n      document.removeEventListener(\"mouseup\", stopScrubbing);\n      document.removeEventListener(\"touchmove\", onTouchMove);\n      document.removeEventListener(\"touchend\", stopScrubbing);\n    };\n    const startScrubbing = () => {\n      if (!isSliding.current && mounted.current) {\n        isSliding.current = true;\n        typeof handlers?.onScrubStart === \"function\" && handlers.onScrubStart();\n        setActive(true);\n        bindEvents();\n      }\n    };\n    const stopScrubbing = () => {\n      if (isSliding.current && mounted.current) {\n        isSliding.current = false;\n        setActive(false);\n        unbindEvents();\n        setTimeout(() => {\n          typeof handlers?.onScrubEnd === \"function\" && handlers.onScrubEnd();\n        }, 0);\n      }\n    };\n    const onMouseDown = event => {\n      startScrubbing();\n      event.preventDefault();\n      onMouseMove(event);\n    };\n    const onMouseMove = event => onScrub({\n      x: event.clientX,\n      y: event.clientY\n    });\n    const onTouchStart = event => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      startScrubbing();\n      onTouchMove(event);\n    };\n    const onTouchMove = event => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      onScrub({\n        x: event.changedTouches[0].clientX,\n        y: event.changedTouches[0].clientY\n      });\n    };\n    node.addEventListener(\"mousedown\", onMouseDown);\n    node.addEventListener(\"touchstart\", onTouchStart, {\n      passive: false\n    });\n    cleanupRef.current = () => {\n      node.removeEventListener(\"mousedown\", onMouseDown);\n      node.removeEventListener(\"touchstart\", onTouchStart);\n    };\n  }, [dir, onChange]);\n  return {\n    ref: refCallback,\n    active\n  };\n}\nexport { clampUseMovePosition, useMove };","map":{"version":3,"names":["clampUseMovePosition","position","x","clamp","y","useMove","onChange","handlers","dir","mounted","useRef","isSliding","frame","active","setActive","useState","cleanupRef","useEffect","current","refCallback","useCallback","node","onScrub","cancelAnimationFrame","requestAnimationFrame","style","userSelect","rect","getBoundingClientRect","width","height","_x","left","top","bindEvents","document","addEventListener","onMouseMove","stopScrubbing","onTouchMove","passive","unbindEvents","removeEventListener","startScrubbing","onScrubStart","setTimeout","onScrubEnd","onMouseDown","event","preventDefault","clientX","clientY","onTouchStart","cancelable","changedTouches","ref"],"sources":["E:\\HOCCODE\\HMS\\FRONTEND\\HMS\\node_modules\\@mantine\\hooks\\src\\use-move\\use-move.ts"],"sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react';\nimport { clamp } from '../utils';\n\nexport interface UseMovePosition {\n  x: number;\n  y: number;\n}\n\nexport function clampUseMovePosition(position: UseMovePosition) {\n  return {\n    x: clamp(position.x, 0, 1),\n    y: clamp(position.y, 0, 1),\n  };\n}\n\nexport interface UseMoveHandlers {\n  onScrubStart?: () => void;\n  onScrubEnd?: () => void;\n}\n\nexport interface UseMoveReturnValue<T extends HTMLElement = any> {\n  ref: React.RefCallback<T | null>;\n  active: boolean;\n}\n\nexport function useMove<T extends HTMLElement = any>(\n  onChange: (value: UseMovePosition) => void,\n  handlers?: UseMoveHandlers,\n  dir: 'ltr' | 'rtl' = 'ltr'\n): UseMoveReturnValue<T> {\n  const mounted = useRef<boolean>(false);\n  const isSliding = useRef(false);\n  const frame = useRef(0);\n  const [active, setActive] = useState(false);\n  const cleanupRef = useRef<(() => void) | null>(null);\n\n  useEffect(() => {\n    mounted.current = true;\n  }, []);\n\n  const refCallback: React.RefCallback<T | null> = useCallback(\n    (node) => {\n      // Clean up previous node if it exists\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        cleanupRef.current = null;\n      }\n\n      if (!node) {\n        return;\n      }\n\n      const onScrub = ({ x, y }: UseMovePosition) => {\n        cancelAnimationFrame(frame.current);\n\n        frame.current = requestAnimationFrame(() => {\n          if (mounted.current && node) {\n            node.style.userSelect = 'none';\n            const rect = node.getBoundingClientRect();\n\n            if (rect.width && rect.height) {\n              const _x = clamp((x - rect.left) / rect.width, 0, 1);\n              onChange({\n                x: dir === 'ltr' ? _x : 1 - _x,\n                y: clamp((y - rect.top) / rect.height, 0, 1),\n              });\n            }\n          }\n        });\n      };\n\n      const bindEvents = () => {\n        document.addEventListener('mousemove', onMouseMove);\n        document.addEventListener('mouseup', stopScrubbing);\n        document.addEventListener('touchmove', onTouchMove, { passive: false });\n        document.addEventListener('touchend', stopScrubbing);\n      };\n\n      const unbindEvents = () => {\n        document.removeEventListener('mousemove', onMouseMove);\n        document.removeEventListener('mouseup', stopScrubbing);\n        document.removeEventListener('touchmove', onTouchMove);\n        document.removeEventListener('touchend', stopScrubbing);\n      };\n\n      const startScrubbing = () => {\n        if (!isSliding.current && mounted.current) {\n          isSliding.current = true;\n          typeof handlers?.onScrubStart === 'function' && handlers.onScrubStart();\n          setActive(true);\n          bindEvents();\n        }\n      };\n\n      const stopScrubbing = () => {\n        if (isSliding.current && mounted.current) {\n          isSliding.current = false;\n          setActive(false);\n          unbindEvents();\n          setTimeout(() => {\n            typeof handlers?.onScrubEnd === 'function' && handlers.onScrubEnd();\n          }, 0);\n        }\n      };\n\n      const onMouseDown = (event: MouseEvent) => {\n        startScrubbing();\n        event.preventDefault();\n        onMouseMove(event);\n      };\n\n      const onMouseMove = (event: MouseEvent) => onScrub({ x: event.clientX, y: event.clientY });\n\n      const onTouchStart = (event: TouchEvent) => {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n\n        startScrubbing();\n        onTouchMove(event);\n      };\n\n      const onTouchMove = (event: TouchEvent) => {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n\n        onScrub({ x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY });\n      };\n\n      node.addEventListener('mousedown', onMouseDown);\n      node.addEventListener('touchstart', onTouchStart, { passive: false });\n\n      // Store cleanup function in ref instead of returning it\n      cleanupRef.current = () => {\n        node.removeEventListener('mousedown', onMouseDown);\n        node.removeEventListener('touchstart', onTouchStart);\n      };\n    },\n    [dir, onChange]\n  );\n\n  return { ref: refCallback, active };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}