{"ast":null,"code":"'use client';\n\nimport { useState, useRef, useCallback } from 'react';\nimport isEqual from 'fast-deep-equal';\nimport { getStatus } from '../../get-status/get-status.mjs';\nimport { clearListState } from '../../lists/clear-list-state.mjs';\nimport { getPath } from '../../paths/get-path.mjs';\nimport 'klona/full';\nfunction useFormStatus({\n  initialDirty,\n  initialTouched,\n  mode,\n  $values\n}) {\n  const [touchedState, setTouchedState] = useState(initialTouched);\n  const [dirtyState, setDirtyState] = useState(initialDirty);\n  const touchedRef = useRef(initialTouched);\n  const dirtyRef = useRef(initialDirty);\n  const setTouched = useCallback(values => {\n    const resolvedValues = typeof values === \"function\" ? values(touchedRef.current) : values;\n    touchedRef.current = resolvedValues;\n    if (mode === \"controlled\") {\n      setTouchedState(resolvedValues);\n    }\n  }, []);\n  const setDirty = useCallback((values, forceUpdate = false) => {\n    const resolvedValues = typeof values === \"function\" ? values(dirtyRef.current) : values;\n    dirtyRef.current = resolvedValues;\n    if (mode === \"controlled\" || forceUpdate) {\n      setDirtyState(resolvedValues);\n    }\n  }, []);\n  const resetTouched = useCallback(() => setTouched({}), []);\n  const resetDirty = useCallback(values => {\n    const newSnapshot = values ? {\n      ...$values.refValues.current,\n      ...values\n    } : $values.refValues.current;\n    $values.setValuesSnapshot(newSnapshot);\n    setDirty({});\n  }, []);\n  const setFieldTouched = useCallback((path, touched) => {\n    setTouched(currentTouched => {\n      if (getStatus(currentTouched, path) === touched) {\n        return currentTouched;\n      }\n      return {\n        ...currentTouched,\n        [path]: touched\n      };\n    });\n  }, []);\n  const setFieldDirty = useCallback((path, dirty, forceUpdate) => {\n    setDirty(currentDirty => {\n      if (getStatus(currentDirty, path) === dirty) {\n        return currentDirty;\n      }\n      return {\n        ...currentDirty,\n        [path]: dirty\n      };\n    }, forceUpdate);\n  }, []);\n  const setCalculatedFieldDirty = useCallback((path, value) => {\n    const currentDirty = getStatus(dirtyRef.current, path);\n    const dirty = !isEqual(getPath(path, $values.getValuesSnapshot()), value);\n    const clearedState = clearListState(path, dirtyRef.current);\n    clearedState[path] = dirty;\n    setDirty(clearedState, currentDirty !== dirty);\n  }, []);\n  const isTouched = useCallback(path => getStatus(touchedRef.current, path), []);\n  const clearFieldDirty = useCallback(path => setDirty(current => {\n    if (typeof path !== \"string\") {\n      return current;\n    }\n    const result = clearListState(path, current);\n    delete result[path];\n    if (isEqual(result, current)) {\n      return current;\n    }\n    return result;\n  }), []);\n  const isDirty = useCallback(path => {\n    if (path) {\n      const overriddenValue = getPath(path, dirtyRef.current);\n      if (typeof overriddenValue === \"boolean\") {\n        return overriddenValue;\n      }\n      const sliceOfValues = getPath(path, $values.refValues.current);\n      const sliceOfInitialValues = getPath(path, $values.valuesSnapshot.current);\n      return !isEqual(sliceOfValues, sliceOfInitialValues);\n    }\n    const isOverridden = Object.keys(dirtyRef.current).length > 0;\n    if (isOverridden) {\n      return getStatus(dirtyRef.current);\n    }\n    return !isEqual($values.refValues.current, $values.valuesSnapshot.current);\n  }, []);\n  const getDirty = useCallback(() => dirtyRef.current, []);\n  const getTouched = useCallback(() => touchedRef.current, []);\n  return {\n    touchedState,\n    dirtyState,\n    touchedRef,\n    dirtyRef,\n    setTouched,\n    setDirty,\n    resetDirty,\n    resetTouched,\n    isTouched,\n    setFieldTouched,\n    setFieldDirty,\n    setTouchedState,\n    setDirtyState,\n    clearFieldDirty,\n    isDirty,\n    getDirty,\n    getTouched,\n    setCalculatedFieldDirty\n  };\n}\nexport { useFormStatus };","map":{"version":3,"names":["useFormStatus","initialDirty","initialTouched","mode","$values","touchedState","setTouchedState","useState","dirtyState","setDirtyState","touchedRef","useRef","dirtyRef","setTouched","useCallback","values","resolvedValues","current","setDirty","forceUpdate","resetTouched","resetDirty","newSnapshot","refValues","setValuesSnapshot","setFieldTouched","path","touched","currentTouched","getStatus","setFieldDirty","dirty","currentDirty","setCalculatedFieldDirty","value","isEqual","getPath","getValuesSnapshot","clearedState","clearListState","isTouched","clearFieldDirty","result","isDirty","overriddenValue","sliceOfValues","sliceOfInitialValues","valuesSnapshot","isOverridden","Object","keys","length","getDirty","getTouched"],"sources":["E:\\HOCCODE\\SMS\\FRONTEND\\hospitalapp\\node_modules\\@mantine\\form\\src\\hooks\\use-form-status\\use-form-status.ts"],"sourcesContent":["import { useCallback, useRef, useState } from 'react';\nimport isEqual from 'fast-deep-equal';\nimport { getStatus } from '../../get-status';\nimport { clearListState } from '../../lists';\nimport { getPath } from '../../paths';\nimport {\n  ClearFieldDirty,\n  FormMode,\n  FormStatus,\n  GetFieldStatus,\n  ResetDirty,\n  ResetStatus,\n  SetCalculatedFieldDirty,\n  SetFieldDirty,\n  SetFieldTouched,\n} from '../../types';\nimport type { $FormValues } from '../use-form-values/use-form-values';\n\nexport interface $FormStatus<Values extends Record<string, any>> {\n  touchedState: FormStatus;\n  dirtyState: FormStatus;\n  touchedRef: React.RefObject<FormStatus>;\n  dirtyRef: React.RefObject<FormStatus>;\n  setTouched: React.Dispatch<React.SetStateAction<FormStatus>>;\n  setDirty: React.Dispatch<React.SetStateAction<FormStatus>>;\n  resetDirty: ResetStatus;\n  resetTouched: ResetStatus;\n  isTouched: GetFieldStatus<Values>;\n  setFieldTouched: SetFieldTouched<Values>;\n  setFieldDirty: SetFieldDirty<Values>;\n  setTouchedState: React.Dispatch<React.SetStateAction<FormStatus>>;\n  setDirtyState: React.Dispatch<React.SetStateAction<FormStatus>>;\n  clearFieldDirty: ClearFieldDirty;\n  isDirty: GetFieldStatus<Values>;\n  getDirty: () => FormStatus;\n  getTouched: () => FormStatus;\n  setCalculatedFieldDirty: SetCalculatedFieldDirty<Values>;\n}\n\ninterface UseFormStatusInput<Values extends Record<string, any>> {\n  initialDirty: FormStatus;\n  initialTouched: FormStatus;\n  mode: FormMode;\n  $values: $FormValues<Values>;\n}\n\nexport function useFormStatus<Values extends Record<string, any>>({\n  initialDirty,\n  initialTouched,\n  mode,\n  $values,\n}: UseFormStatusInput<Values>): $FormStatus<Values> {\n  const [touchedState, setTouchedState] = useState(initialTouched);\n  const [dirtyState, setDirtyState] = useState(initialDirty);\n\n  const touchedRef = useRef(initialTouched);\n  const dirtyRef = useRef(initialDirty);\n\n  const setTouched = useCallback((values: FormStatus | ((current: FormStatus) => FormStatus)) => {\n    const resolvedValues = typeof values === 'function' ? values(touchedRef.current) : values;\n    touchedRef.current = resolvedValues;\n\n    if (mode === 'controlled') {\n      setTouchedState(resolvedValues);\n    }\n  }, []);\n\n  const setDirty = useCallback(\n    (values: FormStatus | ((current: FormStatus) => FormStatus), forceUpdate = false) => {\n      const resolvedValues = typeof values === 'function' ? values(dirtyRef.current) : values;\n      dirtyRef.current = resolvedValues;\n\n      if (mode === 'controlled' || forceUpdate) {\n        setDirtyState(resolvedValues);\n      }\n    },\n    []\n  );\n\n  const resetTouched: ResetStatus = useCallback(() => setTouched({}), []);\n\n  const resetDirty: ResetDirty<Values> = useCallback((values) => {\n    const newSnapshot = values\n      ? { ...$values.refValues.current, ...values }\n      : $values.refValues.current;\n    $values.setValuesSnapshot(newSnapshot);\n    setDirty({});\n  }, []);\n\n  const setFieldTouched: SetFieldTouched<Values> = useCallback((path, touched) => {\n    setTouched((currentTouched) => {\n      if (getStatus(currentTouched, path) === touched) {\n        return currentTouched;\n      }\n\n      return { ...currentTouched, [path]: touched };\n    });\n  }, []);\n\n  const setFieldDirty: SetFieldDirty<Values> = useCallback((path, dirty, forceUpdate) => {\n    setDirty((currentDirty) => {\n      if (getStatus(currentDirty, path) === dirty) {\n        return currentDirty;\n      }\n\n      return { ...currentDirty, [path]: dirty };\n    }, forceUpdate);\n  }, []);\n\n  const setCalculatedFieldDirty: SetCalculatedFieldDirty<Values> = useCallback((path, value) => {\n    const currentDirty = getStatus(dirtyRef.current, path);\n    const dirty = !isEqual(getPath(path, $values.getValuesSnapshot()), value);\n    const clearedState = clearListState(path, dirtyRef.current);\n    clearedState[path as string] = dirty;\n    setDirty(clearedState, currentDirty !== dirty);\n  }, []);\n\n  const isTouched: GetFieldStatus<Values> = useCallback(\n    (path) => getStatus(touchedRef.current, path),\n    []\n  );\n\n  const clearFieldDirty: ClearFieldDirty = useCallback(\n    (path) =>\n      setDirty((current) => {\n        if (typeof path !== 'string') {\n          return current;\n        }\n\n        const result = clearListState(path, current);\n        delete result[path];\n\n        if (isEqual(result, current)) {\n          return current;\n        }\n\n        return result;\n      }),\n    []\n  );\n\n  const isDirty: GetFieldStatus<Values> = useCallback((path) => {\n    if (path) {\n      const overriddenValue = getPath(path, dirtyRef.current);\n      if (typeof overriddenValue === 'boolean') {\n        return overriddenValue;\n      }\n\n      const sliceOfValues = getPath(path, $values.refValues.current);\n      const sliceOfInitialValues = getPath(path, $values.valuesSnapshot.current);\n      return !isEqual(sliceOfValues, sliceOfInitialValues);\n    }\n\n    const isOverridden = Object.keys(dirtyRef.current).length > 0;\n    if (isOverridden) {\n      return getStatus(dirtyRef.current);\n    }\n\n    return !isEqual($values.refValues.current, $values.valuesSnapshot.current);\n  }, []);\n\n  const getDirty = useCallback(() => dirtyRef.current, []);\n  const getTouched = useCallback(() => touchedRef.current, []);\n\n  return {\n    touchedState,\n    dirtyState,\n    touchedRef,\n    dirtyRef,\n    setTouched,\n    setDirty,\n    resetDirty,\n    resetTouched,\n    isTouched,\n    setFieldTouched,\n    setFieldDirty,\n    setTouchedState,\n    setDirtyState,\n    clearFieldDirty,\n    isDirty,\n    getDirty,\n    getTouched,\n    setCalculatedFieldDirty,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}