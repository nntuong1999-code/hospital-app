{"ast":null,"code":"'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useDidUpdate } from '../use-did-update/use-did-update.mjs';\nfunction useSelection(input) {\n  const [selectionSet, setSelectionSet] = useState(new Set(input.defaultSelection || []));\n  useDidUpdate(() => {\n    if (input.resetSelectionOnDataChange) {\n      setSelectionSet(/* @__PURE__ */new Set());\n    }\n  }, [input.data, input.resetSelectionOnDataChange]);\n  const select = useCallback(selected => {\n    setSelectionSet(state => {\n      if (!state.has(selected)) {\n        const newSet = new Set(state);\n        newSet.add(selected);\n        return newSet;\n      }\n      return state;\n    });\n  }, []);\n  const deselect = useCallback(deselected => {\n    setSelectionSet(state => {\n      if (state.has(deselected)) {\n        const newSet = new Set(state);\n        newSet.delete(deselected);\n        return newSet;\n      }\n      return state;\n    });\n  }, []);\n  const toggle = useCallback(toggled => {\n    setSelectionSet(state => {\n      const newSet = new Set(state);\n      if (state.has(toggled)) {\n        newSet.delete(toggled);\n      } else {\n        newSet.add(toggled);\n      }\n      return newSet;\n    });\n  }, []);\n  const resetSelection = useCallback(() => {\n    setSelectionSet(/* @__PURE__ */new Set());\n  }, []);\n  const setSelection = useCallback(selection => {\n    setSelectionSet(new Set(selection));\n  }, []);\n  const isAllSelected = useCallback(() => {\n    if (input.data.length === 0) {\n      return false;\n    }\n    return input.data.every(item => selectionSet.has(item));\n  }, [selectionSet, input.data]);\n  const isSomeSelected = useCallback(() => {\n    return input.data.some(item => selectionSet.has(item));\n  }, [selectionSet, input.data]);\n  return [Array.from(selectionSet), {\n    select,\n    deselect,\n    toggle,\n    isAllSelected,\n    isSomeSelected,\n    setSelection,\n    resetSelection\n  }];\n}\nexport { useSelection };","map":{"version":3,"names":["useSelection","input","selectionSet","setSelectionSet","useState","Set","defaultSelection","useDidUpdate","resetSelectionOnDataChange","data","select","useCallback","selected","state","has","newSet","add","deselect","deselected","delete","toggle","toggled","resetSelection","setSelection","selection","isAllSelected","length","every","item","isSomeSelected","some","Array","from"],"sources":["E:\\HOCCODE\\HMS\\FRONTEND\\HMS\\node_modules\\@mantine\\hooks\\src\\use-selection\\use-selection.ts"],"sourcesContent":["import { useCallback, useState } from 'react';\nimport { useDidUpdate } from '../use-did-update/use-did-update';\n\nexport interface UseSelectionInput<T> {\n  /** The array of items to select from */\n  data: T[];\n\n  /** The initial selection, empty array by default */\n  defaultSelection?: T[];\n\n  /** If true, selection is reset when data changes */\n  resetSelectionOnDataChange?: boolean;\n}\n\nexport interface UseSelectionHandlers<T> {\n  /** Add an item to the selection */\n  select: (selected: T) => void;\n\n  /** Remove an item from the selection */\n  deselect: (deselected: T) => void;\n\n  /** Toggle an item's selection state */\n  toggle: (toggled: T) => void;\n\n  /** Returns true if all items from the `data` are selected */\n  isAllSelected: () => boolean;\n\n  /** Returns true if at least one item from the `data` is selected */\n  isSomeSelected: () => boolean;\n\n  /** Set the selection to a specific array of items */\n  setSelection: (selection: T[]) => void;\n\n  /** Clear all selections */\n  resetSelection: () => void;\n}\n\nexport type UseSelectionReturnValue<T> = readonly [T[], UseSelectionHandlers<T>];\n\nexport function useSelection<T>(input: UseSelectionInput<T>): UseSelectionReturnValue<T> {\n  const [selectionSet, setSelectionSet] = useState<Set<T>>(new Set(input.defaultSelection || []));\n\n  useDidUpdate(() => {\n    if (input.resetSelectionOnDataChange) {\n      setSelectionSet(new Set());\n    }\n  }, [input.data, input.resetSelectionOnDataChange]);\n\n  const select = useCallback((selected: T) => {\n    setSelectionSet((state) => {\n      if (!state.has(selected)) {\n        const newSet = new Set(state);\n        newSet.add(selected);\n        return newSet;\n      }\n      return state;\n    });\n  }, []);\n\n  const deselect = useCallback((deselected: T) => {\n    setSelectionSet((state) => {\n      if (state.has(deselected)) {\n        const newSet = new Set(state);\n        newSet.delete(deselected);\n        return newSet;\n      }\n      return state;\n    });\n  }, []);\n\n  const toggle = useCallback((toggled: T) => {\n    setSelectionSet((state) => {\n      const newSet = new Set(state);\n      if (state.has(toggled)) {\n        newSet.delete(toggled);\n      } else {\n        newSet.add(toggled);\n      }\n      return newSet;\n    });\n  }, []);\n\n  const resetSelection = useCallback(() => {\n    setSelectionSet(new Set());\n  }, []);\n\n  const setSelection = useCallback((selection: T[]) => {\n    setSelectionSet(new Set(selection));\n  }, []);\n\n  const isAllSelected = useCallback(() => {\n    if (input.data.length === 0) {\n      return false;\n    }\n    return input.data.every((item) => selectionSet.has(item));\n  }, [selectionSet, input.data]);\n\n  const isSomeSelected = useCallback(() => {\n    return input.data.some((item) => selectionSet.has(item));\n  }, [selectionSet, input.data]);\n\n  return [\n    Array.from(selectionSet),\n    {\n      select,\n      deselect,\n      toggle,\n      isAllSelected,\n      isSomeSelected,\n      setSelection,\n      resetSelection,\n    },\n  ];\n}\n"],"mappings":";;;;AAuCO,SAASA,aAAgBC,KAAA,EAAyD;EACvF,MAAM,CAACC,YAAA,EAAcC,eAAe,IAAIC,QAAA,CAAiB,IAAIC,GAAA,CAAIJ,KAAA,CAAMK,gBAAA,IAAoB,EAAE,CAAC;EAE9FC,YAAA,CAAa,MAAM;IACjB,IAAIN,KAAA,CAAMO,0BAAA,EAA4B;MACpCL,eAAA,gBAAgB,IAAIE,GAAA,EAAK;IAC3B;EACF,GAAG,CAACJ,KAAA,CAAMQ,IAAA,EAAMR,KAAA,CAAMO,0BAA0B,CAAC;EAEjD,MAAME,MAAA,GAASC,WAAA,CAAaC,QAAA,IAAgB;IAC1CT,eAAA,CAAiBU,KAAA,IAAU;MACzB,IAAI,CAACA,KAAA,CAAMC,GAAA,CAAIF,QAAQ,GAAG;QACxB,MAAMG,MAAA,GAAS,IAAIV,GAAA,CAAIQ,KAAK;QAC5BE,MAAA,CAAOC,GAAA,CAAIJ,QAAQ;QACnB,OAAOG,MAAA;MACT;MACA,OAAOF,KAAA;IACT,CAAC;EACH,GAAG,EAAE;EAEL,MAAMI,QAAA,GAAWN,WAAA,CAAaO,UAAA,IAAkB;IAC9Cf,eAAA,CAAiBU,KAAA,IAAU;MACzB,IAAIA,KAAA,CAAMC,GAAA,CAAII,UAAU,GAAG;QACzB,MAAMH,MAAA,GAAS,IAAIV,GAAA,CAAIQ,KAAK;QAC5BE,MAAA,CAAOI,MAAA,CAAOD,UAAU;QACxB,OAAOH,MAAA;MACT;MACA,OAAOF,KAAA;IACT,CAAC;EACH,GAAG,EAAE;EAEL,MAAMO,MAAA,GAAST,WAAA,CAAaU,OAAA,IAAe;IACzClB,eAAA,CAAiBU,KAAA,IAAU;MACzB,MAAME,MAAA,GAAS,IAAIV,GAAA,CAAIQ,KAAK;MAC5B,IAAIA,KAAA,CAAMC,GAAA,CAAIO,OAAO,GAAG;QACtBN,MAAA,CAAOI,MAAA,CAAOE,OAAO;MACvB,OAAO;QACLN,MAAA,CAAOC,GAAA,CAAIK,OAAO;MACpB;MACA,OAAON,MAAA;IACT,CAAC;EACH,GAAG,EAAE;EAEL,MAAMO,cAAA,GAAiBX,WAAA,CAAY,MAAM;IACvCR,eAAA,gBAAgB,IAAIE,GAAA,EAAK;EAC3B,GAAG,EAAE;EAEL,MAAMkB,YAAA,GAAeZ,WAAA,CAAaa,SAAA,IAAmB;IACnDrB,eAAA,CAAgB,IAAIE,GAAA,CAAImB,SAAS,CAAC;EACpC,GAAG,EAAE;EAEL,MAAMC,aAAA,GAAgBd,WAAA,CAAY,MAAM;IACtC,IAAIV,KAAA,CAAMQ,IAAA,CAAKiB,MAAA,KAAW,GAAG;MAC3B,OAAO;IACT;IACA,OAAOzB,KAAA,CAAMQ,IAAA,CAAKkB,KAAA,CAAOC,IAAA,IAAS1B,YAAA,CAAaY,GAAA,CAAIc,IAAI,CAAC;EAC1D,GAAG,CAAC1B,YAAA,EAAcD,KAAA,CAAMQ,IAAI,CAAC;EAE7B,MAAMoB,cAAA,GAAiBlB,WAAA,CAAY,MAAM;IACvC,OAAOV,KAAA,CAAMQ,IAAA,CAAKqB,IAAA,CAAMF,IAAA,IAAS1B,YAAA,CAAaY,GAAA,CAAIc,IAAI,CAAC;EACzD,GAAG,CAAC1B,YAAA,EAAcD,KAAA,CAAMQ,IAAI,CAAC;EAE7B,OAAO,CACLsB,KAAA,CAAMC,IAAA,CAAK9B,YAAY,GACvB;IACEQ,MAAA;IACAO,QAAA;IACAG,MAAA;IACAK,aAAA;IACAI,cAAA;IACAN,YAAA;IACAD;EAAA,EAEJ;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}