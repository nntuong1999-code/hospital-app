{"ast":null,"code":"'use client';\n\nimport { useRef, useMemo, useEffect } from 'react';\nimport { useCallbackRef } from '../utils/use-callback-ref/use-callback-ref.mjs';\nfunction useDebouncedCallback(callback, options) {\n  const {\n    delay,\n    flushOnUnmount,\n    leading\n  } = typeof options === \"number\" ? {\n    delay: options,\n    flushOnUnmount: false,\n    leading: false\n  } : options;\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = useRef(0);\n  const lastCallback = useMemo(() => {\n    const currentCallback = Object.assign((...args) => {\n      window.clearTimeout(debounceTimerRef.current);\n      const isFirstCall = currentCallback._isFirstCall;\n      currentCallback._isFirstCall = false;\n      function clearTimeoutAndLeadingRef() {\n        window.clearTimeout(debounceTimerRef.current);\n        debounceTimerRef.current = 0;\n        currentCallback._isFirstCall = true;\n      }\n      if (leading && isFirstCall) {\n        handleCallback(...args);\n        const resetLeadingState = () => {\n          clearTimeoutAndLeadingRef();\n        };\n        const flush2 = () => {\n          if (debounceTimerRef.current !== 0) {\n            clearTimeoutAndLeadingRef();\n            handleCallback(...args);\n          }\n        };\n        const cancel2 = () => {\n          clearTimeoutAndLeadingRef();\n        };\n        currentCallback.flush = flush2;\n        currentCallback.cancel = cancel2;\n        debounceTimerRef.current = window.setTimeout(resetLeadingState, delay);\n        return;\n      }\n      if (leading && !isFirstCall) {\n        const flush2 = () => {\n          if (debounceTimerRef.current !== 0) {\n            clearTimeoutAndLeadingRef();\n            handleCallback(...args);\n          }\n        };\n        const cancel2 = () => {\n          clearTimeoutAndLeadingRef();\n        };\n        currentCallback.flush = flush2;\n        currentCallback.cancel = cancel2;\n        const resetLeadingState = () => {\n          clearTimeoutAndLeadingRef();\n        };\n        debounceTimerRef.current = window.setTimeout(resetLeadingState, delay);\n        return;\n      }\n      const flush = () => {\n        if (debounceTimerRef.current !== 0) {\n          clearTimeoutAndLeadingRef();\n          handleCallback(...args);\n        }\n      };\n      const cancel = () => {\n        clearTimeoutAndLeadingRef();\n      };\n      currentCallback.flush = flush;\n      currentCallback.cancel = cancel;\n      debounceTimerRef.current = window.setTimeout(flush, delay);\n    }, {\n      flush: () => {},\n      cancel: () => {},\n      _isFirstCall: true\n    });\n    return currentCallback;\n  }, [handleCallback, delay, leading]);\n  useEffect(() => () => {\n    if (flushOnUnmount) {\n      lastCallback.flush();\n    } else {\n      lastCallback.cancel();\n    }\n  }, [lastCallback, flushOnUnmount]);\n  return lastCallback;\n}\nexport { useDebouncedCallback };","map":{"version":3,"names":["useDebouncedCallback","callback","options","delay","flushOnUnmount","leading","handleCallback","useCallbackRef","debounceTimerRef","useRef","lastCallback","useMemo","currentCallback","Object","assign","args","window","clearTimeout","current","isFirstCall","_isFirstCall","clearTimeoutAndLeadingRef","resetLeadingState","flush2","flush","cancel2","cancel","setTimeout","useEffect"],"sources":["E:\\HOCCODE\\HMS\\FRONTEND\\HMS\\node_modules\\@mantine\\hooks\\src\\use-debounced-callback\\use-debounced-callback.ts"],"sourcesContent":["import { useEffect, useMemo, useRef } from 'react';\nimport { useCallbackRef } from '../utils';\n\nexport interface UseDebouncedCallbackOptions {\n  delay: number;\n  flushOnUnmount?: boolean;\n  leading?: boolean;\n}\n\nexport type UseDebouncedCallbackReturnValue<T extends (...args: any[]) => any> = ((\n  ...args: Parameters<T>\n) => void) & { flush: () => void; cancel: () => void };\n\nexport function useDebouncedCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  options: number | UseDebouncedCallbackOptions\n) {\n  const { delay, flushOnUnmount, leading } =\n    typeof options === 'number'\n      ? { delay: options, flushOnUnmount: false, leading: false }\n      : options;\n\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = useRef(0);\n\n  const lastCallback = useMemo(() => {\n    const currentCallback = Object.assign(\n      (...args: Parameters<T>) => {\n        window.clearTimeout(debounceTimerRef.current);\n\n        const isFirstCall = currentCallback._isFirstCall;\n        currentCallback._isFirstCall = false;\n\n        function clearTimeoutAndLeadingRef() {\n          window.clearTimeout(debounceTimerRef.current);\n          debounceTimerRef.current = 0;\n          currentCallback._isFirstCall = true;\n        }\n\n        if (leading && isFirstCall) {\n          handleCallback(...args);\n\n          const resetLeadingState = () => {\n            clearTimeoutAndLeadingRef();\n          };\n\n          const flush = () => {\n            if (debounceTimerRef.current !== 0) {\n              clearTimeoutAndLeadingRef();\n              handleCallback(...args);\n            }\n          };\n\n          const cancel = () => {\n            clearTimeoutAndLeadingRef();\n          };\n\n          currentCallback.flush = flush;\n          currentCallback.cancel = cancel;\n          debounceTimerRef.current = window.setTimeout(resetLeadingState, delay);\n          return;\n        }\n\n        if (leading && !isFirstCall) {\n          const flush = () => {\n            if (debounceTimerRef.current !== 0) {\n              clearTimeoutAndLeadingRef();\n              handleCallback(...args);\n            }\n          };\n\n          const cancel = () => {\n            clearTimeoutAndLeadingRef();\n          };\n\n          currentCallback.flush = flush;\n          currentCallback.cancel = cancel;\n\n          const resetLeadingState = () => {\n            clearTimeoutAndLeadingRef();\n          };\n          debounceTimerRef.current = window.setTimeout(resetLeadingState, delay);\n          return;\n        }\n\n        const flush = () => {\n          if (debounceTimerRef.current !== 0) {\n            clearTimeoutAndLeadingRef();\n            handleCallback(...args);\n          }\n        };\n\n        const cancel = () => {\n          clearTimeoutAndLeadingRef();\n        };\n\n        currentCallback.flush = flush;\n        currentCallback.cancel = cancel;\n        debounceTimerRef.current = window.setTimeout(flush, delay);\n      },\n      {\n        flush: () => {},\n        cancel: () => {},\n        _isFirstCall: true,\n      }\n    );\n    return currentCallback;\n  }, [handleCallback, delay, leading]);\n\n  useEffect(\n    () => () => {\n      if (flushOnUnmount) {\n        lastCallback.flush();\n      } else {\n        lastCallback.cancel();\n      }\n    },\n    [lastCallback, flushOnUnmount]\n  );\n\n  return lastCallback;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}