{"ast":null,"code":"'use client';\n\nimport { useRef, useState, useCallback } from 'react';\nimport { getPath } from '../../paths/get-path.mjs';\nimport { setPath } from '../../paths/set-path.mjs';\nfunction useFormValues({\n  initialValues,\n  onValuesChange,\n  mode\n}) {\n  const initialized = useRef(false);\n  const [stateValues, setStateValues] = useState(initialValues || {});\n  const refValues = useRef(stateValues);\n  const valuesSnapshot = useRef(stateValues);\n  const setValues = useCallback(({\n    values,\n    subscribers,\n    updateState = true,\n    mergeWithPreviousValues = true\n  }) => {\n    const previousValues = refValues.current;\n    const resolvedValues = values instanceof Function ? values(refValues.current) : values;\n    const updatedValues = mergeWithPreviousValues ? {\n      ...previousValues,\n      ...resolvedValues\n    } : resolvedValues;\n    refValues.current = updatedValues;\n    if (updateState) {\n      setStateValues(updatedValues);\n      if (mode === \"uncontrolled\") {\n        refValues.current = updatedValues;\n      }\n    }\n    onValuesChange?.(updatedValues, previousValues);\n    subscribers?.filter(Boolean).forEach(subscriber => subscriber({\n      updatedValues,\n      previousValues\n    }));\n  }, [onValuesChange]);\n  const setFieldValue = useCallback(payload => {\n    const currentValue = getPath(payload.path, refValues.current);\n    const updatedValue = payload.value instanceof Function ? payload.value(currentValue) : payload.value;\n    if (currentValue !== updatedValue) {\n      const previousValues = refValues.current;\n      const updatedValues = setPath(payload.path, updatedValue, refValues.current);\n      setValues({\n        values: updatedValues,\n        updateState: payload.updateState\n      });\n      payload.subscribers?.filter(Boolean).forEach(subscriber => subscriber({\n        path: payload.path,\n        updatedValues,\n        previousValues\n      }));\n    }\n  }, [setValues]);\n  const setValuesSnapshot = useCallback(payload => {\n    valuesSnapshot.current = payload;\n  }, []);\n  const initialize = useCallback((values, onInitialize) => {\n    if (!initialized.current) {\n      initialized.current = true;\n      setValues({\n        values,\n        updateState: mode === \"controlled\"\n      });\n      setValuesSnapshot(values);\n      onInitialize();\n    }\n  }, [setValues]);\n  const resetValues = useCallback(() => {\n    setValues({\n      values: valuesSnapshot.current,\n      updateState: true,\n      mergeWithPreviousValues: false\n    });\n  }, [setValues]);\n  const getValues = useCallback(() => refValues.current, []);\n  const getValuesSnapshot = useCallback(() => valuesSnapshot.current, []);\n  const resetField = useCallback((path, subscribers) => {\n    const snapshotValue = getPath(path, valuesSnapshot.current);\n    if (typeof snapshotValue === \"undefined\") {\n      return;\n    }\n    setFieldValue({\n      path,\n      value: snapshotValue,\n      updateState: mode === \"controlled\",\n      subscribers\n    });\n  }, [setFieldValue, mode]);\n  return {\n    initialized,\n    stateValues,\n    refValues,\n    valuesSnapshot,\n    setValues,\n    setFieldValue,\n    resetValues,\n    setValuesSnapshot,\n    initialize,\n    getValues,\n    getValuesSnapshot,\n    resetField\n  };\n}\nexport { useFormValues };","map":{"version":3,"names":["useFormValues","initialValues","onValuesChange","mode","initialized","useRef","stateValues","setStateValues","useState","refValues","valuesSnapshot","setValues","useCallback","values","subscribers","updateState","mergeWithPreviousValues","previousValues","current","resolvedValues","Function","updatedValues","filter","Boolean","forEach","subscriber","setFieldValue","payload","currentValue","getPath","path","updatedValue","value","setPath","setValuesSnapshot","initialize","onInitialize","resetValues","getValues","getValuesSnapshot","resetField","snapshotValue"],"sources":["E:\\HOCCODE\\HMS\\FRONTEND\\HMS\\node_modules\\@mantine\\form\\src\\hooks\\use-form-values\\use-form-values.ts"],"sourcesContent":["import { useCallback, useRef, useState } from 'react';\nimport { getPath, setPath } from '../../paths';\nimport { FormMode } from '../../types';\n\nexport interface $FormValues<Values extends Record<PropertyKey, any>> {\n  initialized: React.RefObject<boolean>;\n  stateValues: Values;\n  refValues: React.RefObject<Values>;\n  valuesSnapshot: React.RefObject<Values>;\n  setValues: (payload: SetValuesInput<Values>) => void;\n  setFieldValue: (payload: SetFieldValueInput<Values>) => void;\n  resetValues: () => void;\n  setValuesSnapshot: (payload: Values) => void;\n  initialize: (values: Values, onInitialize: () => void) => void;\n  getValues: () => Values;\n  getValuesSnapshot: () => Values;\n  resetField: (\n    path: PropertyKey,\n    subscribers?: (SetFieldValueSubscriber<Values> | null | undefined)[]\n  ) => void;\n}\n\nexport interface SetValuesSubscriberPayload<Values> {\n  path?: PropertyKey;\n  updatedValues: Values;\n  previousValues: Values;\n}\n\nexport interface SetValuesInput<Values> {\n  values: Partial<Values> | ((values: Values) => Partial<Values>);\n  mergeWithPreviousValues?: boolean;\n  updateState?: boolean;\n  subscribers?: (SetFieldValueSubscriber<Values> | null | undefined)[];\n}\n\nexport type SetFieldValueSubscriber<Values> = (payload: SetValuesSubscriberPayload<Values>) => void;\n\nexport interface SetFieldValueInput<Values> {\n  path: PropertyKey;\n  value: any;\n  updateState?: boolean;\n  subscribers?: (SetFieldValueSubscriber<Values> | null | undefined)[];\n}\n\ninterface UseFormValuesInput<Values extends Record<PropertyKey, any>> {\n  initialValues: Values | undefined;\n  mode: FormMode;\n  onValuesChange?: ((values: Values, previousValues: Values) => void) | undefined;\n}\n\nexport function useFormValues<Values extends Record<PropertyKey, any>>({\n  initialValues,\n  onValuesChange,\n  mode,\n}: UseFormValuesInput<Values>): $FormValues<Values> {\n  const initialized = useRef(false);\n  const [stateValues, setStateValues] = useState<Values>(initialValues || ({} as Values));\n  const refValues = useRef(stateValues);\n  const valuesSnapshot = useRef(stateValues);\n\n  const setValues = useCallback(\n    ({\n      values,\n      subscribers,\n      updateState = true,\n      mergeWithPreviousValues = true,\n    }: SetValuesInput<Values>) => {\n      const previousValues = refValues.current;\n      const resolvedValues = values instanceof Function ? values(refValues.current) : values;\n      const updatedValues = mergeWithPreviousValues\n        ? { ...previousValues, ...resolvedValues }\n        : (resolvedValues as Values);\n      refValues.current = updatedValues;\n      if (updateState) {\n        setStateValues(updatedValues);\n        if (mode === 'uncontrolled') {\n          refValues.current = updatedValues;\n        }\n      }\n      onValuesChange?.(updatedValues, previousValues);\n      subscribers\n        ?.filter(Boolean)\n        .forEach((subscriber) => subscriber!({ updatedValues, previousValues }));\n    },\n    [onValuesChange]\n  );\n\n  const setFieldValue = useCallback(\n    (payload: SetFieldValueInput<Values>) => {\n      const currentValue = getPath(payload.path, refValues.current);\n      const updatedValue =\n        payload.value instanceof Function ? payload.value(currentValue) : payload.value;\n\n      if (currentValue !== updatedValue) {\n        const previousValues = refValues.current;\n        const updatedValues = setPath(payload.path, updatedValue, refValues.current);\n        setValues({ values: updatedValues, updateState: payload.updateState });\n\n        payload.subscribers\n          ?.filter(Boolean)\n          .forEach((subscriber) =>\n            subscriber!({ path: payload.path, updatedValues, previousValues })\n          );\n      }\n    },\n    [setValues]\n  );\n\n  const setValuesSnapshot = useCallback((payload: Values) => {\n    valuesSnapshot.current = payload;\n  }, []);\n\n  const initialize = useCallback(\n    (values: Values, onInitialize: () => void) => {\n      if (!initialized.current) {\n        initialized.current = true;\n        setValues({ values, updateState: mode === 'controlled' });\n        setValuesSnapshot(values);\n        onInitialize();\n      }\n    },\n    [setValues]\n  );\n\n  const resetValues = useCallback(() => {\n    setValues({\n      values: valuesSnapshot.current,\n      updateState: true,\n      mergeWithPreviousValues: false,\n    });\n  }, [setValues]);\n\n  const getValues = useCallback(() => refValues.current, []);\n  const getValuesSnapshot = useCallback(() => valuesSnapshot.current, []);\n\n  const resetField = useCallback(\n    (path: PropertyKey, subscribers?: (SetFieldValueSubscriber<Values> | null | undefined)[]) => {\n      const snapshotValue = getPath(path, valuesSnapshot.current);\n      if (typeof snapshotValue === 'undefined') {\n        return;\n      }\n      setFieldValue({\n        path,\n        value: snapshotValue,\n        updateState: mode === 'controlled',\n        subscribers,\n      });\n    },\n    [setFieldValue, mode]\n  );\n\n  return {\n    initialized,\n    stateValues,\n    refValues,\n    valuesSnapshot,\n    setValues,\n    setFieldValue,\n    resetValues,\n    setValuesSnapshot,\n    initialize,\n    getValues,\n    getValuesSnapshot,\n    resetField,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}