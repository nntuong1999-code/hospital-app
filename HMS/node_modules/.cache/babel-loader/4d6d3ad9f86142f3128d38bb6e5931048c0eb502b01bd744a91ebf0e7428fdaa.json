{"ast":null,"code":"'use client';\n\nimport { round } from './parsers.mjs';\nfunction hsvaToRgbaObject({\n  h,\n  s,\n  v,\n  a\n}) {\n  const _h = h / 360 * 6;\n  const _s = s / 100;\n  const _v = v / 100;\n  const hh = Math.floor(_h);\n  const l = _v * (1 - _s);\n  const c = _v * (1 - (_h - hh) * _s);\n  const d = _v * (1 - (1 - _h + hh) * _s);\n  const module = hh % 6;\n  return {\n    r: round([_v, c, l, l, d, _v][module] * 255),\n    g: round([d, _v, _v, c, l, l][module] * 255),\n    b: round([l, l, d, _v, _v, c][module] * 255),\n    a: round(a, 2)\n  };\n}\nfunction hsvaToRgba(color, includeAlpha) {\n  const {\n    r,\n    g,\n    b,\n    a\n  } = hsvaToRgbaObject(color);\n  if (!includeAlpha) {\n    return `rgb(${r}, ${g}, ${b})`;\n  }\n  return `rgba(${r}, ${g}, ${b}, ${round(a, 2)})`;\n}\nfunction hsvaToHsl({\n  h,\n  s,\n  v,\n  a\n}, includeAlpha) {\n  const hh = (200 - s) * v / 100;\n  const result = {\n    h: Math.round(h),\n    s: Math.round(hh > 0 && hh < 200 ? s * v / 100 / (hh <= 100 ? hh : 200 - hh) * 100 : 0),\n    l: Math.round(hh / 2)\n  };\n  if (!includeAlpha) {\n    return `hsl(${result.h}, ${result.s}%, ${result.l}%)`;\n  }\n  return `hsla(${result.h}, ${result.s}%, ${result.l}%, ${round(a, 2)})`;\n}\nfunction formatHexPart(number) {\n  const hex = number.toString(16);\n  return hex.length < 2 ? `0${hex}` : hex;\n}\nfunction hsvaToHex(color) {\n  const {\n    r,\n    g,\n    b\n  } = hsvaToRgbaObject(color);\n  return `#${formatHexPart(r)}${formatHexPart(g)}${formatHexPart(b)}`;\n}\nfunction hsvaToHexa(color) {\n  const a = Math.round(color.a * 255);\n  return `${hsvaToHex(color)}${formatHexPart(a)}`;\n}\nconst CONVERTERS = {\n  hex: hsvaToHex,\n  hexa: color => hsvaToHexa(color),\n  rgb: color => hsvaToRgba(color, false),\n  rgba: color => hsvaToRgba(color, true),\n  hsl: color => hsvaToHsl(color, false),\n  hsla: color => hsvaToHsl(color, true)\n};\nfunction convertHsvaTo(format, color) {\n  if (!color) {\n    return \"#000000\";\n  }\n  if (!(format in CONVERTERS)) {\n    return CONVERTERS.hex(color);\n  }\n  return CONVERTERS[format](color);\n}\nexport { convertHsvaTo, hsvaToHex, hsvaToHexa, hsvaToHsl, hsvaToRgba, hsvaToRgbaObject };","map":{"version":3,"names":["hsvaToRgbaObject","h","s","v","a","_h","_s","_v","hh","Math","floor","l","c","d","module","r","round","g","b","hsvaToRgba","color","includeAlpha","hsvaToHsl","result","formatHexPart","number","hex","toString","length","hsvaToHex","hsvaToHexa","CONVERTERS","hexa","rgb","rgba","hsl","hsla","convertHsvaTo","format"],"sources":["E:\\HOCCODE\\HMS\\FRONTEND\\HMS\\node_modules\\@mantine\\core\\src\\components\\ColorPicker\\converters\\converters.ts"],"sourcesContent":["import { ColorFormat, HsvaColor, RgbaColor } from '../ColorPicker.types';\nimport { round } from './parsers';\n\nexport function hsvaToRgbaObject({ h, s, v, a }: HsvaColor): RgbaColor {\n  const _h = (h / 360) * 6;\n  const _s = s / 100;\n  const _v = v / 100;\n\n  const hh = Math.floor(_h);\n  const l = _v * (1 - _s);\n  const c = _v * (1 - (_h - hh) * _s);\n  const d = _v * (1 - (1 - _h + hh) * _s);\n  const module = hh % 6;\n\n  return {\n    r: round([_v, c, l, l, d, _v][module] * 255),\n    g: round([d, _v, _v, c, l, l][module] * 255),\n    b: round([l, l, d, _v, _v, c][module] * 255),\n    a: round(a, 2),\n  };\n}\n\nexport function hsvaToRgba(color: HsvaColor, includeAlpha: boolean) {\n  const { r, g, b, a } = hsvaToRgbaObject(color);\n\n  if (!includeAlpha) {\n    return `rgb(${r}, ${g}, ${b})`;\n  }\n\n  return `rgba(${r}, ${g}, ${b}, ${round(a, 2)})`;\n}\n\nexport function hsvaToHsl({ h, s, v, a }: HsvaColor, includeAlpha: boolean) {\n  const hh = ((200 - s) * v) / 100;\n\n  const result = {\n    h: Math.round(h),\n    s: Math.round(hh > 0 && hh < 200 ? ((s * v) / 100 / (hh <= 100 ? hh : 200 - hh)) * 100 : 0),\n    l: Math.round(hh / 2),\n  };\n\n  if (!includeAlpha) {\n    return `hsl(${result.h}, ${result.s}%, ${result.l}%)`;\n  }\n\n  return `hsla(${result.h}, ${result.s}%, ${result.l}%, ${round(a, 2)})`;\n}\n\nfunction formatHexPart(number: number) {\n  const hex = number.toString(16);\n  return hex.length < 2 ? `0${hex}` : hex;\n}\n\nexport function hsvaToHex(color: HsvaColor) {\n  const { r, g, b } = hsvaToRgbaObject(color);\n  return `#${formatHexPart(r)}${formatHexPart(g)}${formatHexPart(b)}`;\n}\n\nexport function hsvaToHexa(color: HsvaColor) {\n  const a = Math.round(color.a * 255);\n\n  return `${hsvaToHex(color)}${formatHexPart(a)}`;\n}\n\nconst CONVERTERS: Record<ColorFormat, (color: HsvaColor) => string> = {\n  hex: hsvaToHex,\n  hexa: (color) => hsvaToHexa(color),\n  rgb: (color) => hsvaToRgba(color, false),\n  rgba: (color) => hsvaToRgba(color, true),\n  hsl: (color) => hsvaToHsl(color, false),\n  hsla: (color) => hsvaToHsl(color, true),\n};\n\nexport function convertHsvaTo(format: ColorFormat, color: HsvaColor) {\n  if (!color) {\n    return '#000000';\n  }\n\n  if (!(format in CONVERTERS)) {\n    return CONVERTERS.hex(color);\n  }\n\n  return CONVERTERS[format](color);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}