{"ast":null,"code":"'use client';\n\nimport { useState } from 'react';\nfunction useQueue({\n  initialValues = [],\n  limit\n}) {\n  const [state, setState] = useState({\n    state: initialValues.slice(0, limit),\n    queue: initialValues.slice(limit)\n  });\n  const add = (...items) => setState(current => {\n    const results = [...current.state, ...current.queue, ...items];\n    return {\n      state: results.slice(0, limit),\n      queue: results.slice(limit)\n    };\n  });\n  const update = fn => setState(current => {\n    const results = fn([...current.state, ...current.queue]);\n    return {\n      state: results.slice(0, limit),\n      queue: results.slice(limit)\n    };\n  });\n  const cleanQueue = () => setState(current => ({\n    state: current.state,\n    queue: []\n  }));\n  return {\n    state: state.state,\n    queue: state.queue,\n    add,\n    update,\n    cleanQueue\n  };\n}\nexport { useQueue };","map":{"version":3,"names":["useQueue","initialValues","limit","state","setState","useState","slice","queue","add","items","current","results","update","fn","cleanQueue"],"sources":["E:\\HOCCODE\\HMS\\FRONTEND\\HMS\\node_modules\\@mantine\\hooks\\src\\use-queue\\use-queue.ts"],"sourcesContent":["import { useState } from 'react';\n\nexport interface UseQueueOptions<T> {\n  /** Initial values to be added to the queue */\n  initialValues?: T[];\n\n  /** Maximum number of items in the state */\n  limit: number;\n}\n\nexport interface UseQueueReturnValue<T> {\n  /** Array of items in the queue */\n  queue: T[];\n\n  /** Array of items in the state */\n  state: T[];\n\n  /** Function to add items to state or queue */\n  add: (...items: T[]) => void;\n\n  /** Function to apply updates to current items */\n  update: (fn: (state: T[]) => T[]) => void;\n\n  /** Function to clear the queue */\n  cleanQueue: () => void;\n}\n\nexport function useQueue<T>({\n  initialValues = [],\n  limit,\n}: UseQueueOptions<T>): UseQueueReturnValue<T> {\n  const [state, setState] = useState({\n    state: initialValues.slice(0, limit),\n    queue: initialValues.slice(limit),\n  });\n\n  const add = (...items: T[]) =>\n    setState((current) => {\n      const results = [...current.state, ...current.queue, ...items];\n\n      return {\n        state: results.slice(0, limit),\n        queue: results.slice(limit),\n      };\n    });\n\n  const update = (fn: (state: T[]) => T[]) =>\n    setState((current) => {\n      const results = fn([...current.state, ...current.queue]);\n\n      return {\n        state: results.slice(0, limit),\n        queue: results.slice(limit),\n      };\n    });\n\n  const cleanQueue = () => setState((current) => ({ state: current.state, queue: [] }));\n\n  return {\n    state: state.state,\n    queue: state.queue,\n    add,\n    update,\n    cleanQueue,\n  };\n}\n"],"mappings":";;;AA2BO,SAASA,SAAY;EAC1BC,aAAA,GAAgB,EAAC;EACjBC;AACF,GAA+C;EAC7C,MAAM,CAACC,KAAA,EAAOC,QAAQ,IAAIC,QAAA,CAAS;IACjCF,KAAA,EAAOF,aAAA,CAAcK,KAAA,CAAM,GAAGJ,KAAK;IACnCK,KAAA,EAAON,aAAA,CAAcK,KAAA,CAAMJ,KAAK;EAAA,CACjC;EAED,MAAMM,GAAA,GAAMA,CAAA,GAAIC,KAAA,KACdL,QAAA,CAAUM,OAAA,IAAY;IACpB,MAAMC,OAAA,GAAU,CAAC,GAAGD,OAAA,CAAQP,KAAA,EAAO,GAAGO,OAAA,CAAQH,KAAA,EAAO,GAAGE,KAAK;IAE7D,OAAO;MACLN,KAAA,EAAOQ,OAAA,CAAQL,KAAA,CAAM,GAAGJ,KAAK;MAC7BK,KAAA,EAAOI,OAAA,CAAQL,KAAA,CAAMJ,KAAK;IAAA,CAC5B;EACF,CAAC;EAEH,MAAMU,MAAA,GAAUC,EAAA,IACdT,QAAA,CAAUM,OAAA,IAAY;IACpB,MAAMC,OAAA,GAAUE,EAAA,CAAG,CAAC,GAAGH,OAAA,CAAQP,KAAA,EAAO,GAAGO,OAAA,CAAQH,KAAK,CAAC;IAEvD,OAAO;MACLJ,KAAA,EAAOQ,OAAA,CAAQL,KAAA,CAAM,GAAGJ,KAAK;MAC7BK,KAAA,EAAOI,OAAA,CAAQL,KAAA,CAAMJ,KAAK;IAAA,CAC5B;EACF,CAAC;EAEH,MAAMY,UAAA,GAAaA,CAAA,KAAMV,QAAA,CAAUM,OAAA,KAAa;IAAEP,KAAA,EAAOO,OAAA,CAAQP,KAAA;IAAOI,KAAA,EAAO;EAAC,CAAE,CAAE;EAEpF,OAAO;IACLJ,KAAA,EAAOA,KAAA,CAAMA,KAAA;IACbI,KAAA,EAAOJ,KAAA,CAAMI,KAAA;IACbC,GAAA;IACAI,MAAA;IACAE;EAAA,CACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}